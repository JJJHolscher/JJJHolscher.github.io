<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"104ff063e0df93fe9997e60efb7dcf70719c55bc768c075807af67ee4fcb22451dacbe932b29d9416aefbe63591cbc6833f4ffc0b6687b49f2e26a7f9f75ec92f549cd9b74e872efffdfc80374ae8037de5f589eb67950a7f5ee519a8324be92f830adfada4bb93c0eb4d0e555f7e6d5b315454d5fde36fe21c067172845a8a4a6674d20c1a1bbb4c598def61c37a97b34c84792952755e5b7e612049d679b9ac3f36dc0888fe6367ab8fb7d1bd58c552369f8c0b61ef91918428b0c82c94273408e43ce9e67f942c56b081dfdc324f7b784800d99dadade0023fc5e56aeb7760589bac6f148573db7333e504605ec8eb8769979c40036cc49f6432b3ec81675b04d690fcdcf0da4bd675d3d28124675f17db63486bdc9e232b394a00229b908270c94043d67c981ec103a305c56647916515f46951a934c61f3ad0f0371652306f535773bd54e7ec7971be2222e38e408162039806aa62b9c0dbd4f1f42f751ae12c58f1f2e846c194445765f81622e57dc83251b5d9aa7425fae28be36318230400c73b7570a822f2d3f2891b4ce0de705ce436073c1d7ba464734f1f6312b5a476f6d3dbe8c257cd0fe1da9052113764320bd589e3da638d1e8c57814df5ba902940cb55c5ef3f8a2a2fbea4aa5f1fcda90f8773e58fd79fe47665451b2cd960235934e8a796195eb13b62e206aafec590dddb8a96d7428b84331790593abdfb6c0eebe46e624cc8bb2fc83e2596027ba64ddd16c75a67fb837e9235bab9849a5e068a6fdffa41d1e05835a007f33cd6285263878b9dec66134a0793264e22e77167ba5d39c6180a8261c80bbea4551f3b3e75474b18a014ad3022bef724b0300f1f2160738037923e47baf75f207711a9f8f9bc2f36138516cacbc230e82404156a7963837d7fc1df77f7541d15157d706850e100635f67675f2b76b57e4e28f0ee673563093226404fbd4c4a2ae410af38ccadc2cfcfe76de25a9e1a2f09997a380fa3519ed0676f66f5b9f5460f6112c822fd32aec99c61e43bd52af29422c17f7be44b72eafb60f554fc58d2f79e3338438829efbec8227419a31dd40d15ede0dfe6d92453b5b531283a04ec9b480ee54d3961aded4441a9d5a9cf128cbd3faeea42ad0c19b98f89b038284399c3bde7652a79c1e0f3bc40d4e7a4f8f9972abd4217c860639745e45aec458881987dea1315b41d883b53054c2ddc34e4e27085b2ba5ecb6000a1c217cd3fae2bb99eefdcdda1803cb1f42856b81984d146785a14e4020a6d3de3863a7e1a4e4b7d9c576371dbc945c6bb8f4f62e95faae8a36f4585d23c60d7f83e4354ee0913d86caedb3bd3d40b14551a7abcb2d9346b176ba6db72f26d150f6316e9ce2a75d3b04e9ebbd4d6541faf66aeaea978c40d1f2ffb228946e9bb6cb29a807aa2dd62031bbf48b672596dd8321b17d3bcc72db236787ec079d8d584a41f861e206eb5e4cfa5501976762ad8db8ef3783e1d99a577361949e99caaeaded1673b285cb4ca4edd214a7e7fb055e8b453a8439c0e123e71fa56a972111fa99f62526dd20a5efa036c1e67bd2b14746163ed7d935bb4eefea92eabf00e3da9c16163d261a9e7db1b981c83fddd605c2d04da60775444970a02e6c8cf43d88d2f47fc265a5a99fea512d0f6d8793c0fd496349dbae8b30faf8298d5316428f1caddd64b24b3c6053ca5ef3b78291dc062fdc50efae30b91d7a29c2fd443ea4ccf5c7af9c43b7147f8fe02f41ddaf6b7e53f4dcd285ab5969a86f416e2e34e66ba14ed15bf9f1710e60eb32442c94be05f3f9baaff7b86eed4b29da170e19b1878fc7b783b0273d6aa03dee028b503b2c5ad70799e02c21e39489e7c92db3568031bd0c6451650ef4ed3fe18f8e046d257282166e2078b9748aa90766bca6d2fd5cc771cd249fadf685aed3293d5dbb9e3752819ba14f77c0a9db62e08c8e338d10ea9a96a5ec9f02dab9ce49a3927cb911c883c2580f64f9f24601c511971fb3b9796a01308b679f7f979dafbf5ae59ed818870b5e00175b7e067e59fadc42162b399118be161b7da7eb07c18ed88a572a5a7e913d30825e39a89ae0f50fc7d687256b0aa66a69b887818c649f73696fe0fc3b6bef01d0603e65899e9bcf67c82ab71835d6be6477ef79643db1b321c1c6d69c89dddd534903a427938bc2050cf1048358bbb38ed5f95fbdf2a8908835ff92d1167624071ca3fc09c44b0fc3bdf733d5e9813dd81e49ca3bcfab4c492a82ef04b792bf43316954ad567fc64523058133061b869070b0e9de96a1111ec2b218536767050f35f2bc1867a87f5b3690bfb508405908784ab596a3cac4db0e650831c30097e7723c7ee52494d13d70dcf9b2b8ac3c9e3a60ca96710627bd03d3b101f89b3483fdb4a7444eb39a9766f630d4be6c6f92b6348f6bd90dfa8deb95844ddd541ed7dc1ad19eb4e59e9a7b2d747e0982f71b8a3b93bda2203259c512dae50c04ddcb86b111afd2c9f6254a84a35a504a82b63c86060b5d6006b85c1eb8574509936d4bbb581cc359ce19d1afbb41ea6cf98a819b61a017a7a8b0592b4a4ee024eb82fa55909033b9dc6bd6c85e26b155f07ba480754b27d155676a86823bca5dcd8baac76fb145b3eb2111351f0e93dcebd3ec93db41c1e35763c6ebadd739f9048092141034b9774e9a4714a6f29ea384348fb5547b0929132af68af058c7daa3069f92c15778f9c527a7077d7cb12b75a884711f73e3a294eb8eda4fcab6de508158ba5fdd9a0511bc8176ed3b846485fa95fc687680c5bd15ad6af39da516132e4ba48f3ad2bcb6e36a3630b2ef818fc642fd846f930d12a0ecb6cc4ed4818cb297d946372c958e45abe87c4817bced7767d04e860c0b9fa89b45c65ca046c0e177fe0f4bbf6c288dcf205e332f3d9bf05857c88221bc49ac9a8ba8d3e190ddfd0c799d81083cca467dc21268895a3421bb4c41eb6aa0a126c120a7818e6c688b191ae96626811c90a6ab6a2951f63367b6fc957fbc034d08783e0f48cdfd29b17cdd332b0cca8a09e3e4f1b7c0c06e918bbcbd3c00790f98a51509c57c54c709521a506d2e58526c6b71338ac5b635cebd6206faad1ce4b1af978da8f5347df01c57569e63a1e5fb453686d0148fc8f47dfbc3177018d0f6cf2b8936ccce1de11bed0998b6311906e6f4065a9034eb8137cfadb1f33c0afdf7a463b223f1f4da555fbf2a3af3832a1d2e3379abb14f34890f41e13c313cb9a3f814384dd286105617ba1354ad380fc79f021be16db0493ef0175248ec62f103590db9b1cc94771825ac374008aa2964d32e0d8d22b90e4f1411a61b435b5efb9650442550880f9453e772a066ae1f9088f583dc29513cfc1e247d639c43586c23c5efd9cd1a132518263d07f301dbccafbb0906b9c34506dd17cb290881023cf046911924f25e3d01b3f4e86fc4e48a62f59ff5111dd99b49197f3384f344f551849ce99e748d26502b22453c625564b443e7f6b3263cb1304013effe779ff2f8b053bc8ca1db52ea4fe94f6ac2cba6e489cbf06ae08a8fa7338f14b064b350cf600c816bcb1d403205e024e5c4206d9942157dbeea79007f13f1f8473990e7fb8a158fa52e20ef15c5ff33eb3ed4ba1af1013e0ca7c0a67c37f9b3b58615798e5a850d7f54e04fd57188150e65e92ac5ed49207da4d3e714d77e6d3f9a6ff7264aa6b6e117ffda22f14c00d9f3fb56f77f64a4bb3ee479129dd4875aa4ab3ab1856be5f314058b14ac3ed7f7f90c670f335234e0d60b2e6c790079883dd0c7717e7d84989738891766b90dbb5d097d8292c1d92545f80e08c0a062dab342396f9c24e6dc992f602b01d1938b4ab5480dad968bce2061d211b3585c0be50f42b7eccb9b171a4bbdf02a8880b888585c22f68033fbf1dd074d9ddfee11934472dd356cbfc625e2b64c56bb0f69779cf7378c48046412a2121f2721f64d24aceb318ec402b008ad2205a788f3fe2473e4d7b8d5401e8408810cb0861bca550163f2b7ba2bc65ab96aef03c16b71f69bf9ea60cf21b72af2f1d273816f3b7f2bf1ad4b550dc75f107a83df6b6b113772e0fa679cfcbda7f29875d7e19ac4419afc7faf1606c04080c328a68eaf4a46697b07647dad7788bc5f92bc4c1e9554abce6811766f54d61acb98af9283d3fd95a65ab98711a9f4d1872b0fb2b5554cbfab9ca17e87b0bc841bc34c473449b8bf090b0d78ee1f0f3838765871b3ca1f5263406a4030007cba5e70724c550b6c988905b8f2dc502973376ef16900daeb47361f1d34d07ad3beecf2dc19bbf122fa0d37edb584a91942dd58e24194e14750041a1d12750cda0f34bf968ae13cf6a6815fbb6c96a74a3fb7dd2c6f1d7b181ccadda7f408f2eefafc329f3abf6bc4c81c44bd9f86c80c6c669f9667d5a3c8f4ae15cb9c26e11b36a53f5ff1bfdebc55ca1ba1f96ea16949188664f44ecec3267dff478114fa3249183d8e80833935441f7fd567df0ec64aaceae3526a88d6fe487a333d6ee60539794b36e89e2665bc7600741d03362a803e6239645e8cd8bae5fd36f21d6bf4f950cda54267198a1d4bc86be7d459202bbcb553012a7e893b9e027e722beb9cd19bb7bd40362e822c2c4ca0f7d874311eab538ab1a727b25dd8b151bda4397d8bbb23c59b6c0531b2fe614d63cc37e697f276968a5f3b676ef662dcbdf024517a78dab3fbc0319b1ad4575bca093c07bc2fe4be93239a1b3dfe396b2348c54858087657b2d69b60ff3bd244d8dbb2be2c7e36ca65e76773618d3c950764ffa93d824a42008435967172842ffc34203f73e988293ecdbfa37703a58c254d5d64a95ec6c2b3635c385d95b339939c9ce0c081c43d68810f3e04c952bc9965830d8f2d12f34e6f59dcb934a6e4acbaa929706c5604374b45809eb287dc2d572c263d111624debe70172291730e0293c71b712391aef7b1cfea71129fde9b668b12fe63badd89b4523b31001eda51f6727bd5bbcf27f5acec1205edfd18a4e27db70c054a3ba88347087b45d38b6d96f238679fee5b767681c563d1200030c0c2aa2456d1102b3c5fcd3b3f66a4456c8942c8e45bdc8f54a5971e23ed56231d3e9fc59627a85e1f276834aad56f24b38876e85a75e596384a6b001276f55c2e2c470f2618527bed6792ec8fcda8304f21e58fa5a9e068e7459730f58a6f51a97b0200a0b58a89e0530bdc365b0df7959d882b5cf522c5539dd1bb64205697c1c5881f640ccbe4639776f077e99dde2db9ca1c3e76b3aec3d2bb7ea7a0c10be871eb7e133d38a5082fcb7bf1bdd23024b46c567cfe36f67a4ebf8c21b50b88cd7a25b94f70c2aeae172e2e7d8ec8eb29ffbd0e587a3ce974ff1e250b4d15cbee27d65dac2212b013d1389997b0e7b1be0dc7c119a4a3ad3a52d61e3b3e2684f869c758f990497a337e9c36800f5a45a914e10ff5452a4da070c36fac7becf9de950cf6afbe0fa065960214f65b33083335bb68392a1d7693d43b366ed00316710fe8d94bc5575feba6cdec1af5ec6abc9d94c49460ed3619c1618197d7e0bcecd447fd83cd8927432a0f0c7b27c8d361bd34a5bb4eddcac2058eded28f0d0f891d409be37b77a98c59254be38fd09a3c54099a910e6019d832d9c746b398eef645813a15383f315a9a3598ca049e31bf0ad27e4ccd04711a76bce6009bce0785a63f1b7e87f897716f4a5f74550141429e030d6a9b7c49703c03cef033feb631e58e86b3c0bf08730cf3b7bf463010ab79e7377dd964f7e7f6d4ecf5ab7b3916097fea63c6e3c96744934dd9e42271bfcf851157225be731b733a2b4184b72cd432da85d73f66f2395d961ee0b27bfdefc90b8994749a8e130dae56839c787f3a40cdc4a06fc730d56bd1401592c6786f9b2d07dd5c58312b74ca2338d38f4a5f9c4d0bd1c81bc14af8c5385d2d874ff2a8b2dbb0617dc9a47f6cebfb1b99b293c8f7572479d1f14c4a5c1bf6a36a935f76fe02bd3b0fc0efba6cb044ab1bd96de99f2a878d2b2dcfd6579070b9143af70d0729ca1fd517b9ec66ef298edbf34bb2dcda7941bb9ff9016ece1a73df0be5e6d225696317d21871f088ce4ea72307389d14ebcda5dae410e40587881e7949c629f0c8b46e2d7637dfc7472fea40f851ad138ad866a9cb59d2833eee19985e8e4cdd4aa9492f2ca8287fe6d6ab9322132f8f8fc1401e25d100dde5d30c591ea5163dee03afe67dfaaeb3d243fcb6a26adf5ad2b8cd02cd1f226c494272fe77a5773a078aa30ec8957f52ca69553c11173ae0b2cf355586817dada49f05fff89299be8e18a5adcc0d66d279bd32a057fff412cabe03b6dd800ebfa6a93430dd486782b99974fb53c0dc12ede800e5d5d1674dc2abfec935a05c3663e5900ab0a158b68237c3e5caf4e49aa25ef5ab760d3bc8f635e06959a244ffb1dd828ecdb02f13df716f67435819dbefebebfa2c131a791bce92b50b675b002979765252e5378ebddf1017300e582e04e66208665f078ce51e47b0500f76a4550c3299249efa2e098511de7e4ecee020098758892390f94b9a4e6844cbe40b48c7423336e50c56a7581862dfe35f2cf739759c1d5dcbff9a18a290a1d9c2f1eedb38f369c2193eead3ddeaf093d11cd2bfb4debe1a4bcc80a9236f48b936c37108608f173a7bb3f0eacc42ad0bab9b3618f72fa3011dafa1f815f9ee463b62045570a8696f62ed554cafd6db0fb39d8530dde39ed61c68ee38d59557133a3656f16305296f1f5419ace48d60e8c4157ae6e1c4cf28d45b78c86382e9dff918cd95b2d12eb3df03348d7de08fe9894a2a3225f49249dca9a8abcfe8e822c2898d52b0f585636d35e204133f194929698f4ed8beafffec6bc94cfcc14ca001d41415a430603639b9bd1fca8102e5b44b0ed5fe58d16dbc1a80f60a45dcc17af70fe3d1b227a6164eb53c6c65ee77127f25d9f7fda00386237485d2b7d58b1bd5b63e2d40de8dac3328e38346eb7908756154f51f11740ac5bc9c0aba148cceb96ab11f93761d75efc74809e972d980c1b812ea0887c558a9bea7f3fc5aeaa00ef20e7f81406da23addadf7797d049b63c919bbc828f8090728d8348504208e57bc2e661bccc28339b6d36160c50cd27b756dc1eed6e1700b6c268371a3b257e680ea6c4d6ef266d025516c8635f49fa54d3c8e2d7073ce54a7507193d45074e2dc41b7be94b11b648b4faa2ab729070b2b6efc63fb2f5c5cdd752eda2d577354d7f482ec73eb575ad8eb46bf95f7d8133471297bb57a30e269353b237f01e8d16abc3cbac8b444f6563a97980c0ec8a8dab60eabf963dac9d03ba62fd9f9d9380b94fb5e2a27941fe40d97d9bac4899a039b4011d8a1f4e97ac5f08f1fec49b702efc66f95fef7847b1dff88f376f8e3ae4007cb392c77a520522d91441f6e82a1f202857ff7c3ae5fd407371447af3424be1849ed8c92113a0130957a2147e951e8ce6d7420762383d3a79cb152694513e42143d2ce7d5152b9e172540aa82a21d920f6f0394b4338c7c915c2aa6b382d12605daf454d227e27bd7b36ca7023fe38840184755e3e626fdeea031bbcfa0d51adb8e51710593c5fd549d3ff510a082a4ec1f565cdcdfdf67ab2b1d7c8f692cc513f56cbd263c7febb6003a94a66f78fe808acd6b398e163dab55ea0d185c17df4e8139270194ca49a2d0a13c616e147b60fc5bd56e4a0974f9db192134eded54f048b68f321d185557dc99be40c62a77bfc691b93247a192a46adcf0a12dea7d63ccef8beaa15c1b4344d0a99d82d2ffd582ac6dd25999a3ca294ea029b4f91cae067ef827b5a96fc40dcbe8dfd4202f3bcb20e62cff8e9bd174152f8197d5c7c2e8cec3b01cabcf39ddce4c47bd6ffe043d54fe949058231651bb7b24a92d9d2add6c0ef940786577e4824ac88ba726a26850d44908f897e843ad619d1df70969f959bbb33d1b1442e19294801ee2f4cc6c616a9ef135fb9a5bb8c695e1aae5e8238618db58e0a04c6e60ce0ea308146187a902e51a24d11d765af774d24ad3390e496131861d797473f00ecb7cd39721c7f7a38b3aecff60bafd219053c86a7c97842b8144da14f571029b443fa6ca63272da721001c8165f489970011fd2d77fcdcd02b742e222715cd9b8305ef546c0a392a2b696a578aea03d4a93582a3bfc925140a6d3345e4d53839d644a5f33084fcd1f07edd471ad59e5363591cdbfa4e1bd0a652f295477b326ba27355b83a05e142bde569ade7662400737e5f8d5bb8e59b30eaf8ee03d587ecb75ca614c30a0753a1ee328036b9a53b28ac495ac3780776719dc1f588d9da2ee2f51b15590b341f0bbe7470dfa2053b5b8108e6c6cf73f2262dd52887b603549ef9cfec7922ea74dbf0f4f01edd0e717df0914578483fd6ccaa2991dd818d2ad5123ed354608a5ae5ed6b359527b7fbd98a50a3a11aaf5cbc860237d8cca3f94331c5382b032d283e35aedc31f897f9d83e3aff38f0d0d09fc4c65d774a24d7347f3f54c27aa6199680b625b3826f0a40e99d72804e702d14546069603ab3989aa204dfb236df114b530b40d9b20d5a2581abeb8d13a8e767b38aa61b4d2f19e7046efaf9a0a1ee24e668b8f62742fd76266262ee8ea9da309cbb88f6530d0ac3b3efcb9de9dc51182aae8c32656d141e5444ddfc9cda2833f3864c8f3227521269920906e042ef9d0ee37abc75c1d9e1bcb64d3df9ae4c7fe7f86d0a7d1c664031fff9f4be611f28f393c3282bea06cd2e3751dfe909f0f66eb07a07fe567f35497f8c9ff45efc001470fa6ac808a0fa972e6051eb0ea040eae4b82d59b9c58ded7a4b43a31d432688a68ff714ab3cb7b669875005e29f142dd730c324805e85a169a3089dc132777bd0b9aa7a87e47bc399dad74d11468d0a68954302082fdaa0526f8420aba8087f087d9901a35294727421d72ae9dfd07669aad7cae3c97224abd62687eeb5c013604bd92ba69aba725232a69d50268e0185009f001428da71b14584f8002ed4576aa298e1ca6182bc96962aac7a834e3f7bbf6b59f71dba283e812cf12e268cce710ae682251743bc6b81634ca23446ca40887e00924ca42ba975b405bde98b596170a980acf43eedd461ac4cd0330b3ddffcb72b8282a61cb84f5c35f5403de6c1ae53b161f45c3d69cbc75c2b0af268925e9c3dc8fddd1c439cdd4ea436e2a2b1157e56942be9c9cb294a5510ce69e7a6f90217558b1c7beb2fd3cf77658298e65c2fa44179045fce367d14404d4bc49720f339a2d71934324ac5cd727977c1e0e26b7b1e4595d321e2263d44fad4205ece7be2e6e6d0c8f960cd3198b55cb4bd7af11548d7e395a060292494c72d827feda6dd3b9d8353ccb27463bc9ee9f31daf70af6ea1af38afdd7e9de448c16db4e443b5fb2c0cf80dda8466a992c05e9e0459d64fd6b6b10db7e8a53b9eb90a730e593b27d8594063c2904034641c558e67d9384a10ca6f39521c387b23bf208279a42e288d3d751e4ff22904a525ba2e30b310a3fb7de1c8121dbd72cc7a4278ba4ae86755120f9208a54a1ae06285821adaf9a91c7fad30550cb923d73ff8c86e6133ec54886f033b4eef4f310629c75884eebad8c8d1952cbf2c685f46b6a425d22722ea5963cdc520f34b541ebd027a96324b2a6e9d4d3a531bb4fdf4e16e9783d2b621e08bf44ae4a131292167c867aba70e3d762add3d427cc4ed2b875e4dddf0119863ace0d40097455c4b0d0b097845c268a9ce2024cd2893dd28d1f587946d09f798db81c4e9777a799292bb7c29388c71ea22f724a8a18243de4c869b2a7e3635be68e8c16b115556d0f58107dece01a75c3f1c55d12eb35130d19a3dd6058858aca37e5f7e61d0a43299258077fa5ba497ac9c1faff550fb1f6b39c2c745f7b955594074ef614f93102e92925162c0d7f55653e9a9ac08c4e4e73ac463f3c1056ca519badb0204e0bc066de688e00e3fc4a3d628018b9ad1e91f1b0cc967d9b8172b2cf813eddabd6b20cd00baf51ad326fa0e22fb8ce347f6686e53440fe8836ec85feca2075d9c7e68b31da18ef3515a3912bd69f7d91247124d941273ecbc12f3caa0f8c337cb493d805eda73bb04d34c4abe8a874af11b8996a70c014bcf0eb9cffd361445065753b2d52eb94a92f49789c29e48e2249c6456ea62a4adc46091c68ac8fdb991d8f3d356f91ba7c8c8d28f5bdee6d5dab1b4cb51754df2a1942ef0b19bbfa11133e18c47e3c9c31cb1d4e0fe66bf0bd84a8d89aa38e832b4fe69ade16991dc80f4138ccd91c8db6beb6f8a362d635aa911d0c37c0ff56bc5eb9fa0ffddaf37c2590ed18463587cd1f5a59898a68e997ff83611f9673b4a0963943abda2244cf042f493a89a1942acb40a87c45dfa2ef4786dd4acb1f1ca9deacc1103252a3a61e02e99d0247f3eb7d4bb5572f8e3669648fa3bdbb8420a4b4c1cd1582fde0821926f9d22d97b567facce9d2f6b36e9757de8688fc9cb4fa4a1f63f45314b845e3477ec987b3f5801c15089690486a92a92c458cfce3e22244fc135bf82e9501fbfaa54dd91e6ddd7a4779d5d85a74374b3d3380f6b6bf25ba376dc01a9cb93c0b9fbdd7f571bd0e152d5aeaf36c350cae0b44e6c09add1f73d83d87d1a04678d22fa439d07e796ad70985bac28544a7ed38522cc3ff7f956bfc510c82763b0216162781f1791f5e0304fbc494c708df9064423b72d7ffa3352e827d613a52470eb1c3806407ca7c52c9ec3f8e3cf01ad3e05657c8bfed2f7ea6c14081e63da9475087ac85187ef8717682382022f2936eccdd805f97358e882f39628136562c1bacfbf3af354f7e323130bb6ddae3228dcd2bd65670d867d2be7a9f476709df3e7f1aa2e0c9979857a060fd92d6d85c58b6da0f0ab7219ac438ae08b07d0651630ad6054cdd819fe2a2f930b916235137c20e446d54f99ccf859e189d7edf27c461efc3e03fb2894bc38ad88c0ff35064a66238298facfc7774bf8a8df38de5cd990c0d5d9cabefbb8108feb29344fa18ae5cef5f9ee4f66561e64ff181e5f831e8649244cc0a0a3e7929e53986ba42833c199ae55cdc3ba304f6b6e414b4a403f2d70ecb0a79e40c489c01f3ba34ce0974625073d6dd399d7927cccf533d797ac9e37f95d0afc86a934cc59bcab4bfc03d7db99d7f71d60558609a52f92c0b9dff5351360d083b61ff57320d08b4d14b876e9dcd87cee5660f274a081fad61534ff9333ad56c9938c1fb777e9238062364d3d85fc3666a7a7da0aee0f7798649f296b5ec21fd01d1b0007ebd40c5da8ca04d4f4d65c64f19faf7006df46c50b84d939925d60ca562a2bc74e2f722b0a96475085e110fbba07c603c340353e5266663cf41e6f4f23761c60bbf44bce01e262ec1a85b72376d1d1f61161e8f7bb2aaa725d217fbf297e5fe372e6bf8fa415e3700e74a56cf0133dad1b5aa21084f10ca74715825c2ff7206afdb6ca3fdb6f4f7d6926978d943d61a451b1d8ed5706e20020219441f080710eff25a87a3e87953965f5b784dc9e9346940b98dc133130c77aa950b87c09a10b4142b91c4caad32f462e1ef759371f27d05574d8f4b0843e18aa51f0541cb3e2bd72d7aaf84fe2a7ae352296753ab56fc127a1a6568b5188ca5c6ed34ff15b5241b672d71e58bde577bf1f522f620713315dc792e454133655060eea5db61284e3f26d28cf4e34e371028619541b72497f41f4c3b4965ca796f77ac53bce57bec2a7aa171937da41612fe08349854b933f8712025df19125ddc622fbc4895eb0b6c9fdeecf68d73f69c0a0e49d1d78dedaf87f4f028dce96516c802c747a078179cfd849a3040e6980fd0a54711cb209236f8ee761022a10c69498529dc094e531cc3c77e1aaa008c58973dbc04b094c6eb83e6202ab95d28c64728a3f5581b501c39e16041b57eb1ca8c4ed059e8c18b32d383d4053f8bc30d9aa8861cc4655f0a61a1e984f70d519addd86f02d80b1eae9fa1930375a483f13b799f2c600dedf534024ce792912998f118986a66092ec705b6589c5590be1deef29ef2e79ade8b6c7108afd99b0f2aedfc683f92886654acdeb83c8c2d0b9a24dcfd33592bd55fb3c0a3d2cef49b37faab9b35a5e9f572e0793de6ce07a2b541a3b812af2759df10c7a186570e56265fd188cb8ed251fe1c0611b254eda4a8e52768ab7ebe8d5cefc026e0e543d3fd09a16380b22857ee57c15400aa733e9625edf72561c545a1d8e3b5f7ab18d0054ad49cba0cb78fb078b46d6a47a6a199bc3d3282b3f86d53d5f7938cbc59a016d08fd023b1624079d856c9b76dc9934509b403980fd5ce20a0c452438c77cb84e895f94f6277e1f924528e3461c4cc0322eabfe0958acd0e5b647bc0805f196c0f3899d056b896b37bd343ab7f31bd1f5f206763ada4c67351f25149815f909d1bf87638ec7588765e12d23911f1466180ffe519acb8587cb3c3a166fe94180a63f2508fb80e9e5ceba73410c5e40eb710367bebca99c1cb89b99e7f33e8c539c22ba02efcf8c5f56c51027ea4fc58ffd8d31759aab4189e46aac2ef22b8c098ba0578738e8ee6868fb4a7a1e444793cfc24c806145a641f3be11ed7692aabb02301aa6f801c8c5a9ea6b5ed87b1cc86ee396dfa016e9cb4cbef44c0d404c416c6a0a74f7543c96de62df3e2467cf694ff2253f95fec34bfb7b975a795ad6a9e0e0ae50be7ad91fbc6e47419c785ec09130962e155da919b21b767e7f53c44fcffab8a0fce3ef38e2c366dc0b9d1766965a261718392f3c65c3d7fa1a978d1a620300398c70b4dad031dfe3227cabcf994fc1e8643bba6d74fab3fe7b4711ce0927b0ad6ae40333efd31c4d56a315d753a85016b6811230502cd1de04eca659f9a7210e635a4c3b403ae4a50ad99af36aa2b2ecc458c091af2ab77e3804e81713188150e0a0469a25cd3b5441124cf4fb415ec9880387af834382f1c772c5c75f84ae4ad9958f57ebff52e7ab7409a9746370bbcaeca5a6550e6e7a67bb01481f9813c770cc54fb30c7e52cd5dd4093e63c69efa49015855ce12d9a18a6425937cfb36e10bb9cb0738d12e6041deda0489c8d117a0e212b50e8ec3d2cfd1632d2d54cfda45af3741c334374be256e430ee8041743dfd6b696dc70e8068c54040da638f527e748720c74786d657d0939f367c5ec26046094020dc5bede3089c53464c362b6e671cc8591c16c26c27f3988b7980ba94148e6aeacd7af86cf1bc35669a03fee72df779af322b13c8c483bac505cc420fb4b5709972b7bfcb920dc7cc0d715fc58d07cff4b1dfe09852de48faaec9adcb467147ac65694226463732ffc911f21d1d0ba6e0820349fb69afbd2dccb174ec525e24c1c2c6ed7f40dfcf58ab4a806447009b5c66f5f6305204f5bbabb9c11b245ec311af8828fbab6a1376455a9a29918162d995147b14f392966138b29ea0d0024a69d3e12a8ef8cbe9cc802613b337fd08991b88749eb50df72d3e6deb61b4548d7af37e2890ee035dbba3b42020f3200add64056970f6e55fdfcd760ffda854343f675998b695b4e293e25df9dabccdca2b81c46c795bcedc00d0506208be73abfb07c4d8b873032fdc4492e048f25a9a314c28bf31cf50f7ed5221c4e466d8f8618f3af2bcc73f1d546a50d910742b53dbc31b72ba751dd1e96d69ecaf6c0f198975263cc7f8ab2c0bee4426a4e0511f2c0ce9090c2a2c17921f9c341d6b893d6e1f875efa299fd29dead7d46320512fc22013c4806441b1b61a2ae2c63418d2864f3f4595e78be0ec2f0ca8fe3c83fc22d673ac4ddd93ac4594037c0aa0fbd911549ffbbdbbf3ff8f89cb26be1d3147d55b73498337123483b5b0e8ee7685c5baef5a5d49b82d459d6dabbbb5f5eee27bd0ef59026a5e52186a261c1791d94a641fada672e9c2f3b6383bfdc94a0d4d014444dd8037087f032a582959fae0afd91d7ba107a73cf16cc5ed84f181d3ee748a66c5c49c13ec841fb61f8448f1a20aa59979f337e61917d5bee4669e893102d7ce2a9d98a1cb5e75fbdae8caf021e4c5269efd4b743650d4dd99ca9485c7114f5587df1424e43b69f937ddf21dabb7e2a9ab3184cff834e9783b5df4dd7eb9c8c762c6fb79549925f503210e64a39c3e9f1bd1d28fe80aaa71152f483990059f191786f80208082acc245ae99c9b8fff379c76e15fa80261870a0aa8f6edf11f7a612fdc46c6f63d4c8a716a14785476179509c76a53c8065402850d5e7d5bb55aa39f0d4bb55db6d619f6e6474a720ab84ac5b7fe5b54313857fb943241e52c1442e05bcce03a9118f7df734f256d7bfa548daad43384e55162e39513a49840d5e6e406161cbc1fbd947fa0d5fc78860a9a7b28e71fd2a6ccc25e3069132f973efb01718f40f6d33951a052d5ca1fa2a8a9433cb011d9caa2c9ef994ff85d8248325e36448a86fc9cda4796a6248bf4f868a3c81607fdb466dcecea034c3348244bf8966856b76e1e5af17daf5a8bf46bbc9b80e11bb22db6593dbc8c0d2029175423ee118a9123a54ed8dff86548d60300465bb59d45b280028b2fcfcf2abffb614f4f1164d87eff4d562b11d94517831da1ead7f6f54a91ca9609ca00f0e790da5bb86a1325af0c1d8b172a4dffb278d0742f978554e4f3644d8cc867c0bd7414e6093e846084fa70b98720b58de17a5a028ccdeb23188fb9530349d013c7d8aabfabb0434e7da585687f2fcd640b71678d9e83c9f08347695b9953f5e0877c61435364cca22a72e7fad6ef4dbfff288e6d4b2d68041ed677f3fe8068a119127f88bebb1883e43b6d72dfe29eecbfd4dc88ef1bf50eec763f6f0a1af1f4c0944959894dd5406a7d587a627637ef7bf27b2b6327632c58fe83a93598c1b4dc3d5c092695b11ed00607c76990623382fcdd84bd9c2e32540c431337295412c2f546814031d37a99f8c3beb1889cf7eb69ea32a5875ff67200e94a5a7bd945ddd3f99d74f2e522bec0e27d396599e1834ce35c8f6eeb3dec550fb7951a71ea6bdc908175ee174abed0dcc6446f3fcd24c87c847e90421cf305c926a12804cbc68a8a6e42b021c61299c76e2344e395c481d155af63a6006c6e622d0a980d088eaac567de97b7fd22e424f50492d6e5069fa16ab08f3aa34efb6a00c16dc46967190f531d88a744864a06c04a8e4ab257effef89bd48e3b1a87671802ecf8f7146ce4d8b9536ca8054665fd10e37d6287e0416ccf60e6c21417b49ceefc9067206b5ab2a14d3b1b400a4739214ab16c72d63dc81589de691c495fc4cea3d041261f84975a99bf7f4ee2e13bff8a8351eb80cd3c2ce94affd7c1985fbbc008a29981b5db0de5c4e65707dc4822450836f15573e4382435cde2f39aa075690a0793c07464545341c17ce8a331e73e7b6138fb854abcf4246eb1f8a6f06aa6e13f9f8044c952b17a4fb15e085dddb2c203711cac94428cc6313eaa380d745c422ab50098a3d463418e70bd92e54de65f0b4e1797638d87a9d76c2d2cb6f96e8fc2f67838f54b0de33024061c01233b92c8269e0cee164384d8e7b3643b476863551b53cc7b8215aa26d69da0a5b17eb433db5bfa732e801e3a7bc48b4f0709f6f684efa11aac96fd730014c22b25106771e05c97b5efbebda1369a4087b46c3608c0d84cb3969309ed30665efe43ef8dece898fdeaa394593982c85cd4bbb9e267c95245bcd86a2316c556c8686838d9494379f59673974cdcff2be1005f5ec9573ab1049f22ec938f07c80bc0b1233bf9204ffb3a17f1dc277040c75212c104b7513a4ac834363c9d2eede264d3c89f7f4c9f5f6bedab9053f38c8b4a099f33f9cc1378a09741d0f457aa6395cd37aadcaa3f38a3d2ede8eaaa178237597dd207ab3719cad15ffce8f335d494f6263e691ce49d01dd4e950317e151f0e5b18d0962ebf0dd3efc21a2f6fab148a0983dabe866e9068b9ba73a24013e848c9fc9cf84faaae9e25afdc3770a966ca19940d9e4a1625567bc0cee69830bbc44b1f4ed5917abdc9180cb3a2c2dc5ee3211892be9f4c3127d1d3f938481bcac2ae4e4bee99eb7237810760c24989eeb2f3ae71fbc8e14129b9db7965a6e99ddec47e1644c96f25dc33ec5faa344d7f10afee55fe325217c89b6c036868bd3216b0c0a2167a820e691e8ba6fbae7f1bd832fb36aa352ccd301e46d00ca413042aa567e82cb9de6fc410bde47380e222619673406c8d26a56aec7139e4a067e2a1bb04204444aa0852ff1ddc651c2bc2891002d2ceaee1b8536846803a2b843b6c8f51616980c80a4dc1f43cd3fa557e654bd61d5d48caf37eb06582f485a922d4b6b7881e3785a58ea0323c29c2fde2f3e71467af903cbcf887d6f9c02611abfc2abdd5dad6531f5c2d21e33b80d90ec2818f83e3fa23d7233765851667a7bf659ab4927e01b810ae886cdb20d05761630ac19fcd5a0f8866b393ea531e56479661c3f516709d7fcedd620e582ca8b6915952d91087fe8a9508fba14bdf7785e92136c975c15e6b93915938a94e8702dcfc061578d4318caef457c6024b695e98690575734d89b33ece25963bbc812783093ff4f228ee8a0e236054f013721264ddf12e1db0ed75a4e148225ee41a3c4b6d33c3c6abefd2f093dc6b8cb941adf6fdf83fe628dee0d8fcef8ddb7075c99fee354968e1d3c9b198188472bfb5eb626c158e4df806f8ca772a6ced1e75c4588fc1908fb0851cbbae984fc3599ca0ce59fa494e185317b1ac8be99d9a3157ff5c552f79553280e3e9c202e49d8910733baf1653af9051025637145b8c40679bb9b606a34afeee2d23ba498524dde8c5486b7abbab38bdbed28e0d792f5050d2250709bef384ccce21bb0e610eb4031d007b86dd6e5fece43710ae4c14a0b807f02bf8efa40c6399a4c93461cde0ca940941793d9480a34dbf4d3c663b2ea2b4a0e7cee481048e10030f9f97866181f98ef3b836540b04919e4f9118f9f975e95f6c5339f6a32d972f8ac802224952bd2c1ff83274a941f965eed95877e5a197fdc9e35b1917d8788ad310671f59b76dde0d2626e7e87b5e15d7f737d80173d61557842e5056814a7cb8d93ba95397e0e5115b143db92c4671487cfa3adf3be819db79c2ec6a0ccd773ccf6fa6311b7cb2584ba01b1aad12998c5e25b4bcb55c59afa8f381caf2496369b10d07ce94b73f248b0c423c4dcf8d22d230b7830b6e02065955f59db74776f3fbdbde8be1300c48fd0ce690f7f7d8d285b720b5742ae0df854db008f86d86221a0c06e280801bf8cacb52f2a95775bfe7800822af9a7df8b57dd12758ad7a0213e4e89d2a65daa0b8bce5b8310c0f08cf81d87aa6491d2d91d2c8c6561b6276efeaf857099b26b25bbc5a79311a033dd0e1165e96474dbcc087fe48004d5ba1e776e039e2cfe82dd19d3a736653733042a926efe50736d7d491b71144ca4234b18f9a86258a41bb171e9dbf65f7990fcd5792b2c9c33952326d348b558956cf817205628d9522d7983d3b16d68a123284b0994ba9951498a9c2394441227bdb7fd1ff51c82903b9ab40523181a3fbe353c574513273a3bdda43ae48a4117100d3ce9465d4c3cd8165479fd9c0970ecc816e90658a5e58ee3105e7f9b01d10da7eff0023824994d329c818d919b69a8d32800f0904a47d4f9100ff1dc99e7440020d035a351000d709da038056b0971fcec6b678ce37692cb8909230a07af5a6a9333dfe50aecf130d1873000f9c4174af00bc66cbc0690c9f82f2d563c62302ed89b10d90f5515fa1d98e69d634d12d3989419845bab63e47985a16c7e0cc8f6e4eb86e05f2c6ffba918d5456468a21dec440100203756e6d5f492e871b26950d9888b8cca9850e402bff3829a5fdf0882594d576b40da326c9fa7852ef4cf14ff91b7685eb81ea4023d8fda9ba64402daff898372a5229457600d3980c0dfac972e0ee8e68dc2738a69ec3adf96ae813c0c3c04dc48c73bebdb0a7291bd329c09d91b5419f8bf68dc49cb1c5a22936afba34bfe163bb2b98ff7f2e5e2bb37425e15e9a1037e13b2ed962a68986c4f0dbc764fb09905e081e48b58e2e56109196082f5dc14598009ef8ca64d036c1b5532a8c8909a9929b0600a42f24941d97492296dea256a7a3079a","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"8d0120ce7d5fe9440aff6772cc7bcc9b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
