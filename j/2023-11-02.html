<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"937d6536a07dd65ddd6f3dfba03d65367def2aa0c4f0adc46c60ecec311a7984c1dba320eb34a44fda680d4540dc3d29b1adddeee85eaa1dfbddc7aca8db4191fc7d5799df9f1db92e949cccdc60d1773ce2262eed70fc2612edc10b857a299430de8d5363974b2af30ac0222fd56486ceb44ecd3ee369b599d6ce26a1ca4cd9ad0f13b6617216018a136cacd95f1efab4ed215ab9d53d6fec63d90fda0ef9dec69cc19395ab3109e39f0e59255005253f7575ea016f6453703884b8edee59eacd4ad88b447c3333730bfc90ecbea236eb1e16cb7b1f2bec3b3d539b7474067c3618ca0ef90bbc73c56b5e255f587b5cae9dd9ef1c665dcf7845bce8caff831059f4dd7ee7458f4df3d980c63e3708e5313e635b800a543e21cad4406686c762242a5eae5cf57b79159471327f7aee13f103c51018453811b8c28c14823e78af6569a21fe9ceb3b0d6d5db547f6946af5450541567a87f418ecab2323d5f4524bd406b3e8a7a659dc752f89e1246dae96a7714b8c33b2c946dd0db8c50d7e0440cd37a1e41da8962f287ec101aeccdfb6af7f10fd48a402196070b6b14306c1f06b2c6f3dedfafb6874f088fb32d1c15b8dc30b9334ed41b2de121bc6f536a60ab169ecc345cf58e0c1d39a3da237df291f31774f3be93a88728d0d72f15ff065f1490388cdc3fe69bfa02f08bcf9bf249ff7cacb604e547ff440a06b219e7df0e22f325843644f46d377051a936570f06c270d487f322a4b14b9e2301400a8f3ac3004a1b73e1beae5e873b64c9c922aac3cea2a607c3167b4d78fa3e73d634dc996a4d87b6311ce5baa35ef31074d9399cc38c216e6fda17b8062353b85d63979dcf1536eaf70dbd889c7818e4b127cf5069ef9f4483b76ad992affd497b6dd18ffec1d044227818f810baecb424579a953cd1f4db04d87ed581cfddd0f1bd8e1c9d0301dcd3c794f05f3faa423fe2a954fec25239e28b2b1ecf378e0510a6cdb8c3ac2cbedae5ade2e0bf64af4468a7d2970398aab28a3df0b9b17ce10db70090bb94c17850b481464bddbfb8140cef7b5b34168cadb92f459cfa8660d6b12dbea13ea64ef29eccb45c84e4c810b67adba1ed400a3dd9319d79a0b6627248948b6db8bd344763ef017b531c4418f7aca99852db55233e1d5215872b6976543b4014be7b364b5ff5ab4ed75505c3b103beacc8269d4e99c6bf61c0a498340abe253db88b466511aabbb87ac73a5d2c2bdf8abb0f12138d753ddad21cedda71ddc903ee3a153bea619d05cd1f138b12d7c2d07fb163e51757650d81bad2945e801143222b35a842175af4a49a12aa150ff3987c8eb82b5b743383405158139956f04b981a55e9d1cc7af8bec0f99f706711c85071353ef8a130077c056a040d021bf9f4fde37383a12bbd3b2fb886d57d44d44cb3625550388c7204e97a24c02fd547cf6263e6742821333faebdb316eae5e290d46fd4db1948f8f982851d22ea3e3205a531077bb4e22692bfd792d924246a6b899e799686c5717590dee84745311a154123d0da571ebd27a1310699063c85da8bceedc05fa2b7f8f36674621aefaa616b157349938d021ccb0951541f1e20de838051ef6faa885783b8a7f9c61b54518b875d188b86be9110089c79b267e93d9cca1fe7466000eaad2547295f01933e55c06fcb6a130bd0c4836025189ac1ba3ba9c68742ae720965a44bd921a707e8571afceabb4b9cf3ad044c0a0302ec7814bdd9038b8af32046075b129d5c256aa808af62b22355a8f4c349c0c575f09aab79282692edd5cf5323a42fd12d322bd893d00e48be2657a78f8d18b327f5e06ec739bcb1320333cab0abaa25d3fbbf9e8b02f0501734cbc19bbcc2bdfb2d9a0fb124bcb4cda51749853781870ec5c1a27a307fb2c618d1734ab19a475ab6e9625edd9795eaaaf416dda1ab57da5b3ddb23e0c7de4a9f83b5731c230e0fcb1f06c5da9291c48aed3398742ae0e1c5b04dc62e128d1d2ae6b0448ea83928d89d983d405e7fa234d3370ea7bfb419458a2c5898140488822c97bb62102baeed0df7dae05f2c72c905c46fec2294d13a552307300c9a196edc0bbeaec5709aeeeb1966b5ba6bcd66fee10027145e227d3a272fbcb9371ca3ba595a4444c38a5ecc6a99245d07722f5c0695c6639d72440ab05ac8dc3142a0a5c96dae0d0a7c44260852f5ce4b37234e2aaa90dba0161773b9c83f7a08b299381ef5adebecf41abe21372650321d661f35256b3f487072f9977b137f55e7db7cd1279032aa332ef10cf03acf4b85df8e1fa8117d3a74540b534d12b8f6486a817697c286eedf7a1f1c91672c16d10f9ca83a87761d05a8979cf1eca871ec90933f31578cb81092e8c1a48aea20e1fe9944d036408e2de732a0d3dd18b1d2e4a1f8a089d6f93dc18472ab3755917fb1411da8c91cca10259fb5f71f65c6772e9bf9dcd85b9aa21d1b232e8610aeb3c28d93e61eeb1d24731683706425f02a216a93654044f5896aa4208cec045d74f69eca05e5f5f8b7014791d7609d926c7461cabf40b28daf603fef66393a31eb7210d1af720027bcda4afd0985f19ec58c2c9bce822b6fa09dc93dece46b2a7860c02e4bd85161c69dce2d6c156d05eb06ef57d17d933c081ca3bf4d97e0ed057e7cf0830f5368a9eaeaf70f5a5569716b2cd768decbfd9b54bc6ff9a6c9b458670d476c0b4079492aafa446b4c573dbe486e707598e466ec1b7a0ad120ddd8097b286aeeacf569e55f0a2465817029caf093f5122b1cf04b98428dba7046dad59da518c55b8af61a7986e42a02c393c523f4c7f87ed6302e789bc1efb155290a06c18decc70b0ec5f2ddc2a593f0579d0740422830890b25ce62f23ee3d51d44f88d76127e274992fde4bb957d286ad6cbba9305a095b9c998b92ff4630131e909dedd2c82ef2c81bda2dd0bf9e77b567f71e2d0b4ac2d2afe44305043f1b6ed74f03a9cd81b846825805a7db15154ad8eb688b7af95bb228520695d83af7f3d4ff7303be3862ea4ed61c1faf398a01a89b4ebeddaf32a472a1d587cfdcbf3ae64eefa40fb3561ba8b38b9460db49af1f06bee0ddd5c485f575cd6ebfc2a67ef5f97270d9d3c7ee153d8b060a156d052fa8defd2690588cef991576ba6f6074800b8b515b8704fdb0984b49758c4f49f888227672681014dda66a98b9919fd3e1ae0d54736ea050e39ed0f4170b9130cba5a755b3f0c327da3283cfe291270b73c55d9d778db29205bb75dbd2bf234030b5e86b184f5519039047942df3cbf0a06f369dc9999aaaf41022d1e2d1021af6e3e120fd2a000a3331b5eb202dfe7844b448e6ba3f46d6ef568cdbcef31ee36248f7f8d817bf7e24b4670983743169fb67839b597a110d174165c8dd3a6f7a62c0d57ab8a061655f656ada7ee14959678f928958af007a30f61bcaad2a5e110eda7bcf8c188e4901659abb6c0d42655c559372a6c3170f2470ca5539c1899ddac7a874ac5ceedf2893d945079b6f95b399a748310e320fd05c4f98f647c3a46bac974648496f2938eb7275a991e2b1eabbcbb473fbd00301203dbb951a70c14a8998dd02b4d3e41596da6a5dc5a5ea252e2680304a621e67116b741349184d1e8680597baec917f4c56be68809763298c271fc1f1c9484bfca3cde8f4558359d725149105f3548346061c66d9b2e487f51036fa1ccc00183429e7b8877d4460887fc1c75d111d42118abfcda4f53875fcf9f8f2e38572be04567fbbdb84ea5fa3cb84e9ae38289f06af49c872138e4d0b8013fb4c1ad6d80ccf09c32fa2280d1419e58db2a7589420ea33453869ea09adc013053ea84f61b976ef7fc00ee2318cdf4447125536c62d3a4db9c0c1c9f2962f50957f73269f4c82211f85a4a6cced56e420f599c0e983460241d64e6336c569d7e33c6f524a973cc3735c9a341953073b9b32097aa5f2b761642395cdc9bf21a212d6bc3f440cc63cde9b92f01e9bd3c0f7e778fffeb4e6bccb60363139377949a177f06275f8fe4ac88ae384a85c6f2991daca64166349629954c9ae5614ce986f62dd92d0267f94dcf467eda6c97d7e6f4c0029940ce8c58777225605b5c21dd305287bce5d112eec094bf39fdb204d773d4cf33c96fafced246b6af923533c8efe189f7381431154294c29bf0a27d172b810895e4caa5196aa39f79bc302ae005674fabd72e382ae2067016cab32c1c2a0a06bc89234ebbfd9ac902a32970a9f121defc75276e3f45966d03bd1afeef24342b28468c10d700ba4018629a35b46873282abc458a7abd932ce739f9c78467729222f87f34a501cbb7af5c39f31279fbc8de9b22bd7908dc353073057909babd7566f8d6ab120325bdf0a730711eafe136401cb8c157e16531d11f2530266392237e4a52bf258699de7435ed451203454a912d2e89d42929c19c1facb49ef094ec7917f2d821163dd227bd87c20c738c2beda0d813ec7e0d2ba4de210c184df5a803d92a604321010d8513268b0241efd61cae06914636ff45a1efa96c30772f20074bfbdc90437b7d90af0a49b80471043afcf73822867f5f5560f6b003e9ce229a95727924b3bcb1e8aaa2bc57cd015965090e90763d81196154ead9499a84d7c812dc9443e7890f82dbc749c8143c369533e36d043f3416229e52adfd518198b1ab957ebf707a07a8e96f64213727c176fe7957ed3248d1598377d2a76c5da9b6eca9f7f76bb54f3cdf2301138e0ea8548a4363fb7808dbafac3285c0051a47cfa62041e6894802692b79eaf16f7cd74384d63adf1e384040a2233022ac108f4c428843c089b9beb4b80137cfd52c3d21c41eb254ceafe4c1782dcacb4286f9f7d3aff9049fcb51107b7b980e8770c44e680ac85bf299ef4c01af81388fd89cb40a44154e13f2d19e0a3771bb72774e00f72752c1c6d8286a9a3645d32fb082e261013fe4bac18fa86513461c2a8da6be5b24fdd75829070c3bf1fc805d10b68e69badbdc62f014fe01835b55140db43d30ef6dc33894a96e80a4b6cca52fd09fde2bffdd74d91270539be4f7c009706147350d01773c1483e5d807c9ddcc92fc3dbbb8c9becae81ed2f23acbdf740f0833ce58f5b90af7c09370acb0ca256798429bedc42b0f4fbb1c6aaed363edc4971f16076452013ed236920c776e9549ff759e57611ae90355842f6685e188ca911da11c647aba2ea2c74ed4937039be8a5e40b17f0290465452fa9ab9258e7f2b34d805e6ce7b6cf5eb9184eda59fe740454898ae52d311bcc66466d13468ce4e351c88f37c29494ad14630b06c4aea0bee0f3b18ccd05509d2b909fdc8fc525e76d9cf333eea73cbc7eb50b041579edab7e88f47a85edab5053a22ed85554a295a39e9a1a5a0f5f3d7a2c4893f7f7a88e1cc77eea60c38c24e4509c12593d43d9c7ea20c1bb847f7e49762a1859805d2589b7976e58db217a664d80eb7871e95628e3c69de8d4f8fd35643ec51978a5daccc009f97e9b900441e1197582a6efb22c0ee5842bf73603b7d7b9109888d2e2822c67d7ec285339d0abf254ffbe56f9f453c3c703d7cbd5a3ca925c70e45669010474a5e89f0db371624fca94a0822c2f94175d4d014f7fc98402fe08e57023cfe42b141d467d3430c78d3a3e00902f8bafffef2524e0e83dc8314461bd3ba0286ffe252f0b09e03d497384b24b28bd88826842c32602dbf535c5aa8834df4a2096b848a1292a421eb3aa29d15e89472aab9d52c17f07dfa867cab38bb5d301cbe7d63c27950c7cdb37ae4f0adb6cddd4a739fa66d30c5bb123a40c6a0cd46a17ade8b66ffc99aa67590eb61cdeeec3700fcaa94c6281049d1b92152156c03e91fc16fe99bc136305c28b5b5fdf26da2c3bca52bdd3498bf879e1659470eacc5fa786f31f14ee2bb1e6a6eacb019bda111887b99ac540ca636dfa862f64835daa0be7fe47ce993c049896757cb0e84c20a1c3c3da60efdeebc5553e30f39282c4970383c982e08e60ad0c1a7f5a8bf5cdece728070201520ace33bf12ae6da875a5a4b4a46c41da81d09f5873f62b3f690eb0167f4058013d4aa2dc099df1aeacb6212b48f9b8a8613548f7118c912feee9cca6ad44811aed008d9bc96e04a25d0880f6f633e4eb3053724bc2f87062e9ba0b10a7619f0eb99702610b98c387dbcc2461d52e4ec43b07417e4a8aa1600841cc7339b3f308cba2bd1f02b6ed4a078fd83cc8ae27efd2d2a8546563151f430f917eb53a82047f680d5e0c96c0fb84fda26f1ef49dd8565c3230b846a0f4d1826d50fcce1d6666a3bf2c6c662a0cf1ec4f51b33a4b2ff7ba7dc09fe2e465a9300b0ce5f7df1b8414610b31ce942a21534550e5ae800025197d104a1fb65aad774952e112de472d49fa17756135412afbe2d5ef759e78e513f6cf0fe8e79d60127db9ea4e7a94e10c27711707bd1ece3402bad774b0775a2e89c6ad163af4a87daf365119496bdc222e643aec8ce79dd4a9f61452b72b9187cde1c5090cce67b89e0fbe2abe51b028ab974bad0aa0eca26624b9d5f72d5e9d8bea07d89ebdab5794816c03d1837fd12b4474a285d7949dcaa02df7a131d9e3434b08f19322ed689408d7f5bfa4e0430dd0a6ed41289ec89f44672634324fcf218012f24a7c7754603ae47921187598c4a7205446cce88927b09e09e2d4f00555a4002a0da6fa85b6cd8393ddcf6200dcea1641b15653fe76efe3a0333f7da95c1a7b0f6065b053f20e47c60072bb2b46981ebf9c424a3fa5efb5db2243646dccac79089669b5896b3ecebd557d62d86f776bab4e99da88ab36654da15c2dd988493387a0d36b8503fa1063e7823d73d52302488eb8e63dcd25dd3c74f7b0a5c1a82b6072a2f6a33542f0b513d331494817b85965bed1dbebbdc35240b69040031397553c23643a8272fb67971947441cad7fa0691ce2277d884add6e46536da698dd9073fa37b7f5bc900e9f0740e3cb475d4371f1e80b72341500ec4fef4523a4c0cc7d880c6923950b6557d491787814945b42dd897894c30cd42981789788ce5bf8c9a9c3d8817a489a69e13492e5ea16cffb59f41282e7351323a89d8f204b99347dd45545f93c9bc541f95a9654574607131cc6774d72b9d314296019d2e8916361a98d2a38f778c8aafa76e0687e32d668040cb30d6b8d291302fac481930d4dd18906fd9b4eb189eadc31f86e8c167bdb15f6476fa4f43368a51aa39b0cafcefdebaa14ee40e0bc08f0431c89e8f03560bbc4b9090d69472ed2b2bbb284c4cbb2ca70714a5988d06258c865a54a115f7b1ea6d3f8e0bc838baae946bafe36def1d6608543bc6f070f329ec33bb57890fbb961a6f3c998823037cd6c2434473306851e3ae8854bc6d89323836b5781d1068100a1670f38e1cb35b6f1e3ce0cac9dc9d86f7f513c85b05cd4e4bf80bbac6535389d114a533a22c0ec581277b1f74b6b11e13641489d05cb2e687c80ff69ad124a12951ff7142a06bd3b913e32207a9b4533d79e5895195710b1d5e9dc3a6e6394c5a21e398e9303a1b46080a27b470614ef77340a57fb4e1df4dfaa20ad4aa9871808ead00d75dbcfd53c6aa09d383f016059f08a8c7346a94d33f14a9c409d82b8afddd6a74b9b27849edece62b39c48df1116cc11fefce60f033c18ac8e140dfe4b40285013e0b377a63b9157625f9737aef027885d6de022fd3cb452369fe9092c4b936ce748f398aff8ec94e04d2903516e19ee46f63dbe33eed1c60000ff67c2c376fe7f2eca697c2d86b8b20c369702507650fc9f667deca428e90fa491c913d54779c442b97fa38b444ef663d64f2522bd8ec41c9dab9bef975509da024706d02e1d936120332ea4a7fb2392234f5e13e067f6d907e76101d91a9d7ccac7cfd2e504d49e5bb8cae7bd6cbd79d7d803b5cc02a7683a6030881c5765d4b479d55c27ce2d53ee21fe73434b49d819e0a26c9dc547d52e4a93ff2e5c6a3ad85f13d85d07a8f19d2c961267246e15911111cbc0e5ce76f49ac6eb7b5958c620aa920207dcfe9398c572d5ba655e6d166b6570e6b306d10ec0d0c6d3d435ba3142ee82f4167c42b2b0bac951f6bdf3d93b3f5b2f639196d33013590354be10caa2dc21fcbe7676d6e15524cdb48846d3dfd8ce0e9b174656a6711997f88a3dbd98768ed99a57c232ae1b7c9c73a3b0aaf3a8aafe61db42d4449e8e26e5d055bf840d304eee514685c76bcd4b6700b831832dfe53293abc7bca25fc735619e5873ca11c50dfc9403aded0b53b0ae390b75b197e9cbd5280d3aff43de5593c2397f833f4fa759e1b73032aafac1c6cdeaa7024ce0f63dae44e494089e2b5113b31dcad5f66e4323ae99683bf880e77f4cdc370c2ab53e33fe5504b897c87c30ee73b94987e40f52306d44a904519a09dba71c16ff07ab94097450487ffe2188ea30a12550cb23bb0180df6fbaf92801840cbeee715821f9798d73800ef8aa9c61db3d094741f866d4e989b063577c04a7c78caf9de354cf80cd1b9d2d9fe26b1bf1409ed36faf60ce727b586f1dfb71da14a347f9e1c2c498db9d62ae6fe46588499c88a2d0aa70a0b13e62c5ed2b430fcf1bdbec54f3defb5f1e6c4c2332f513f38045a66e20fa8da1e090ea2e687d0916c71491059c46a17b09a6b1f4584d5f89ed7039d06bfcd05d0d33665a612aa01e3a016bca584666b54d4042d53884df1481eca14694c30ae8a0a412843ab5f8152fd94969bba28fcc460b64d6d1d76a0e7c89744646fd3a79f0430faedf096f2d0453644dd0876d113032db5467c3bd60fe3ca22ca72a695f2d77955f0e83e9decbc6041ab02f068feb9b9fb52358ee857d204d60154df739494b1e313fce449504bd4d3cecfc5a0802865130f531a2033d67f4cd1c4f9385c4088577b72df61ab089b668402ccb0a781b061b6e29c999cc8acbb87337cc3aa129d9af9d345743aa01bb01fd83d3f9f4eb1df32a5beb487f76392997c522b4218c3643570253fdddc6f9440c0bb2290e1fa98b2fbaad9c1eece137d7e2bede3575d96b31773e1397a8d6c1110d630889e11becc914d00271a1713c0626522a5e41adb27a948fa8a2a5bb8b53d8964b7cf4198f1cef8bfe8904dc1cff2d8289c9651a26e1a703566a37bed0c72333edc6ac86ef70b6d935a56ee031c23a548a2e43229f64596b925cda856b080cb885bd293c6daf938035cc0a4df0f43f39989adb541ef8315d0bd17453f503358cb33ad3283bdafb03371901f27bed0389c31c3bac5785fb37e352460369bf6d0bb4a6c96c418e427340e200e501bdfc52b128b9cbe0c2aa762576c07c58b70443969ae806892f91f7e7980daea016bcd1c642453e5e8e158e4fff3e6e8042619e8ee8e4ef5074e80d3d8bbc463746888cb94ed1e92210d3efefb07167fa2b3a935964353ed54421f72399cb7a7c3a5e65bbd417ecf2b0ad8c2348d2bdd93d3bed7ce4460d2e02755c3352cf253e2da99ab9ead86b62036ca867c161dd7c27516da3b6b50945604d4e59967938a205baebc28b2b3b1f609890d177fcc67283b2d15bd75334e075a2d3f5efc5ad80ce52f747a5aec99e540c116943327a14a87ea0a9f90e59ae165e06d9d4268951f3a40a037208fcde0cce01fbc6b8ea51472680dc17a0dd09c1a86e8d54eb6c55943f847fd09f2ff8dc3f3fcf4740a01c94cd29ecee8a54116ef9efa3aab9f79aa8355c485c1e2e79f4d249db2b3a03d075ba91511d175abfee74cf8d4b1fef6b7e7274c2565d2995280d637c3f046ff9594b5a68f58e636f41c9e61be64d822ae55b2750624f4cc021037f82d26cced4e0042e80773aed27ca5c7c0dc29d801648fc5b920197f943e2d77958c6eac7f70a7c656d7258bc60bb775fd0101b0f1f91be4f248861512faf84abb9c85626a013e67bc6f6fb66765565e6e89ff7c4f6c426305dd1335420f62a6b4eed8e2d420f485914072d215dd451946a26a3f6a40beb4d1c3e460e099284b2bcdd1af0f45499a21830139a217aca05cbfa7244ff38c7e97c5638f5e2960b77cdcfac0df5182637ffaf25bb1078c1681d5251084c7aa5ae0f1f026291a194e17e9249824fee5620365ebbabdab257c0633ff6324ced2d361cf04b509dc28c21a37ea30894e2f8143a18696f18defa4a92ef1d9bb0b07b2f35000f47bf6ef045d6b94625decfe974bf8a645ac9618a44a7833c538664b156a6df7199d2f1cc1949cb55e09f1e101b5b2df520916e2c1a61d3a214f2b238a985d9625266fd5b9ec5df2ae4223a4dd8701fe897101cd66b3387160522ae2684df0966c6318b716e9552483d7dccd2273317a4667e1256ef1b2635c61762ceb4b7bf49e171655d7fc22f7ce09ea51c2e7ece23b15abf9db39c6e245ed44280ecd02fdf5bc548229239655c72d0ddea941337f473f993d7b2883531492aea63de5d23c863945c5a637b2c91f6cce6771194e557e44a00e25da69dda9f4a081ee781a63309479a1bba0f43de0af6919bdbff93902b03bb62d679a928fc9c8d85713be3eee53e40bf3cd98e99f0a891b997ec64a07ff5e1546dd4de8640ec5e13e5af01ecbd00bbdd9ff0a1f241b71471686e462b060939037081563c465349779bf51b9d6a7f88296f21300cf40c4cb56d06ec3e462246652eeceeeee1507283f6798c5b6fc3f1d2d50edf9f8f1c67999c2d6714d4361d093d5b945a425841b70370be94928abe2facff31d63dc8068cb6c453ef50a5fb9974bdbc707a27300dc0eec4338e294eb181b030882567889c344293828e4eef6da6eca0006a2756e200a8b2d5f9fe97453ef1408c412cc849a46f43d059d8fd69af27d3b2cb6b58b3fe1e450e4e592db47907d04b3a5ab249e8270cb21f5f658c08218b436b63e1c883c5b7a87170705057aa998fcae455c5f10d7216eaa4e0bf8c86594539383b76360b244173ee8b691d66d9fc2dacf6f3e6db7f2821ace8978e373fa0ab1945b53269a7ebff52e8889b3e09a694c6f1f527e9d18561f2d77d121c33f158fa7aa34d97fb6fedb12c52334afb07b0790c892468fac3ca4a5765a9f4bc40e8533c65f3f22fa5ae998c0e6e2c6f9a1630cf303303a6df6e835c91add8b5bdeab73374b9de75060baa02e64b447c19b7d1b6f3a897c6257f8d379cf060a19ca86f1c47cb30c995bc3cb72659facf2f57e69e2f97c9e266cdb325ddef611209eb0a303f23a9090e259ec0c0056a3cd31d9622b85766ee33de2698ccee42316a9de2cbec9eea8d21483970bf8b3525e533001d9cfce26501c48c807ab7a130c9bfaae7693d1f97488a4162b238850fefc4bee43537379cc12e14cad6ecf0f6f2066c2366699e92a96599c2cb73b9738d02f546b2074172808e450fad77a3c8ca25646f34fd53e1fab3cc973317b6a0236692cca7ffa505ae53d93adfd2744e6b51dbc0419161f9ad0d337a9fdb41f6533eb5599f643a301168d82f3fe67f668d42a7d7d09e15bb739f013bd3b5690ec03f2484eccd135e9a80e237d2b3b07aa4a09e1f0f256c1fc78e54796e87d351d69482ad1d6386711d4440b40492cb3cb547be9ca31b63b89ac6ffec22e55c0acb0ade0dc5b5c0e55b90b0ce74900bcd8400e4b035b55c7d1d794a37cd7df231dc185d8617d86ccb35a19a985df6bba45b6b83ba66044e6bf6101b893cf452ee8eb48b039da37564836ef515a5057adbcffc9c5b694b7fedd50ab09725e36b59c5d4e3db8666d82dcf1984cd091ad8769beead24cc5ded958861fdcedf009b5c6f2dbdf7c5e700061afddc121a8301d3a1c51a47050f8ac0349cb8311e3cd21a3f05799fe0beca1f7e5196458ceabb5fc78d878e2ba61dfec70f42e718b03df167e852a02648cd51235780ff2abaf219395a2eb819dafe6787b1689effe98fc31ad33afb121217ea84fbd1312675a2192031bdaab43398ffda7dbe28675082cc385a427ef10a6c53ae58907aec97da9bac1fd716000a224f43df2b61a38c802dfede77a89a3804ba2d08e8e89469bccd046de2b4f7ea1f596c5766125ae7d031b0467aff73fdf8ee824c8dd28f2c2c4757053c2814c9b8cdc1e220eea5a86b9f0e97dc05a4041c1694d451282ec8398589503be9411b758ce9e62e01a5634b46a9ac84baae48bfcde5744a2ab7b6d25d78d5b35222bfee69c17300c00e510d7bec45c3f3a3a9e4bdd4d07f5f58e623655803a75a68255040f395d1a99d8eff7aa1b33d18b2afbdf1c55278c54a1c3329ab1c21cfec6965c12b17693911225af5570d5da6fcdebe90316b0778924c159ab87fd0c20c6ddf943f9756cef6f404fc7a11274e3097733640a0941fbf3ff574e7c0063ff153363fcf7864388543f999e44df5077d60b38d411f9b6a8f1be410820dee0106d6aa0d4ba58f8a5181b552148ea2b24977591395d2e25a2fc5421229b2acd823abb8614680ab210ee242e0dd01d35220b683cf6ef9eba06bf11dfa81788fa758a9e8c0029ca934818a003809012bf777c967d65f0d61a9e162f1226476aa5218c4014d0bb503bcc90d63047ce7bfdc4a5b5dedaaa4b836d3fe9104791b5981d842466f794277246f1cd11878559127779d4f4ec39c2d17f321f3e70b84acbfdf3573033744ef666c431d0b1d887aa3dac2821d9a8c0e0f3bff3f2bd8dc502ff21379b4b81cf5434bfa3edb9acb4f1f85da9420863161828e10a772c5fa7733c48269d7ddebb31435d5f698fa580ed96d6d6f809e6e37981779dc30363ee20a728082ba0e0db8eb8d317478d0cfb622418eea02a05f23c18a3fb8e3a371750f4c9cbc11a5ff88edfb32c38ae1a29793526f04d84c7e3b9743a2aaecdaef40535e0a9d020d62cdd3597e90d57f1f41ce23597e7660a8e0a069914f422ef634a88c4ae3e1690be686bef5758695014ce277a80ff88216fa4584326d3ca038ca3e7f7a11e082f5bca9ffcf72d375a78e910aab99be6737dbdb3a39d4008be4ec0a33e3a9cfe5e710d48667bd56d0a8c055e11720e290cf8587ef3018c3fa706992fda9e748b7154c80b77503df523976d1a8fb939306f9c57989240dc1f75bfb54c324bdc1717667729238339a061ed3c1f2142eb435e39c0a8ee3bc825faf2e34ae1a166b5415b35ccfbe7dd9a66dacee9299276a8da7f25982a0bf922ea02a97fa65d48beec6ee741ab39e0dd6a6ac37d2859dd2ea0bb395c3f8ee0f29585cb0ed5f9baa2678d737c8b1ce8b72d1122b29b8360dbc8b3f64b5c5d568a9a6fe3ade014b4e6c9e8a488302d22c2d54186dca3359b6f033ae2d9be67dbbae9b785c5eab4498592ff4ffc7d23cf9255860270310a193e5ae9664363d1bb9222e503962753cb4bbc50ce1441a4a64107ea703aae13ff1edfc95a2a1d8ad2fca661d317b844e73cbc46cb122519544c6b9fcb60117674d15045c0116b6f17fd248bcfb06b5d79da5163961d3c756163175009435f347a40805fb4920268310481bd8703686840ffdaaa55f231ee4b352d03d0546e83cb8cc7067e53f0499a05e97cd253ce0a98e92785f92987af23c738185c5903bb9baa30dc995269ff4edffb27da0ce21d2746f7a4b8431478dc17ae197ba2121f56cd56e02e79aa2e69da4dcc051c19f469cb9af28c757263391d40bc477367c171363715ebe24f5af27250317fa0389510cde0fa70a61998ee8e21efc51ea6e165e5b64c5d37d34d8bf78ff62c880075c82ab986317c3e07965dc257a0a7dd38ff3c4e1ab035758914646f78194f232b7f2ee46467229d44f48212bd88b59cc5761cb24cea657b67360819f968fa22e3c51e35fd54d30a4d5a857202045e2e40e44c815efec3c1d0c6e226a740424387b2e97bc4c2f1a058e20e7331048b2a31cf10d6057e45c7658a9c679d27af0666aed78d1825379363a90f30ed6c38c185c88d3b783c4ec67b2c2e89170f93ef4ad18b4faec6d2abff750d3239588626c79cb5bcc728a480a18e7d606e19929d6689df3565f95f7ac6df3e6a6fd4377a62a6325e78b4c846d6e553fa4807519b8bd374fe714060c1f6f4f8e2933cda0327afaa646695ea1f3ed9266bfa7aade272a0214486618edd09eee36a6b0ad503c1d6f414b0ecefba8a05132e6bc2aaf17201bbea9b64eda01f4317ce8af1038642cfb562fb552def7a9c46d4c7f8813576a0d545d4b7b7151ea60a299377acb05b995337ee1af0065d58eaa0d47284ab399418510c760354f0a0c0f980ef1c1975ad4277b3a66cfdb48fa980c0863b2211fb86144dd7520f7a26d100387ce9ab4795fcf330aacf57592699b5d6fe4866a726996581bacdfc920c188b913fb97c2251e6fbb47a323c9468d4085078d446985a1ca84a82c67aa64e5beb010b658d469c48130d003d0b587bd3ff722180d8e486bfc14aa4383dab16f811bedfde54a2e986de173f84085c9c9db49283c0dcab31cd037c3f16632a489641c8169e716f6ab308525f39f7c51c702eb504d583b6cf367ba51bdd8b345b254be50d57ebf3a4cc4fbdb15c66c041fa3e9a8b5b17f266f4d3b231f812a24a7dd439bfc825608be405c2b71d7fdb80990e0b65325d01942073c7af3e10bfae0b87e53f562548bf6c6957876ea974de3ea355686e0073c286e2a0eac7478f9b0bde46120e7a9c6620c3c7909834a34bf1eb617003f607648f4b4afd7d63e263b666e1aeac2dd725ebe7b1bfcec8fe31179129ed88d1c21bd30bfb9af4192cdaff4e6ec95c306c74129bb245c077eaf1d1e7c93178b8881d826e9523e177f639df4a89c9f9f60ee4056c2408128cb41d6e7f53a30bee4038f3da96054352d6598cca2445a034cf95ae58bc2aeee9ca5aa40be0ca54768b7c93d5aa89db4e9d19968d2b1e8ceb2b49b30bb0151848fb1285a213067296b365dc29b14edddaab689140cc23ed46b6df53a999fc4f1abc8235a4fc25519cd3da3534713472d10499691d0013ef8c9a3a519512c2c2b2a21931c23dab03eacbe3ca365b45cc32d4888ef979ef1a2d77c57d9294fbdfffdb136674f390b32020c9d99f2e5aba7bbb3dacd4a4fd8e81794d8a933b29243a4c42b26200495d0612fb6ec25531f9056c8af571f98edd7292c32f0566caa8b40335f791f2547a871739030e70e7ca58ed6db950716e087d4670e21c9d8e0120a43c8cceae54236046763b1b07483831048278f457a08aec27a75072bb582b6ba1ce41f84c3ea65afa2a3784c818abdcbc8ad7948dbd9c17846ace2faa59505e127f4786fd762c256143f49c733e32a73ac47a0b6f2cb99e8759f94a83600ccb1e4cdea4bd2cb63a646188739b4cd742d44fb8d7176119f9530af897f724ff02975f1367f01af66f4396342eee7cf15c6663f9a768945941372d508600c87415d498f13cf3423e180cac8c4c1250951a360c885631f45850e2c7cd5e8b767468a9f4659f61563ae1c83744fcad5c5a9351440a6c72547a7e9e8d04f5a2f7820444c713843823748595f164326757cfdc6d0207b2512dea57a91f7a67d01281bce3880a50ce0825145e286ee2679c733ef2fef3709b1219cd2ba61f59e051ff78f997d917f6816081bd28b931bb993d1726d8851a3716e27a25e358225881b7fab6c986586fdd74a370ad4320cbe9c34a8d322e986136e5668210cf6a5f7d4a2d810b361a14c00d7ce3528f6fb95d501c20ae07f7ae2b05ee40f00351a391dcfc6022244343d5c02edf1c29d4005cc830d40edf92f1212bf6d5707ae2e6fb8c491a5c8082b393eee13973e6baebb3cd525d1ddc0014ac670f13b235869b89e7d20c8c225200c2fdfdc7521e9616333df4e0d16f10a1232fd71dfcbc664e0a551ef0b9a8c406f89ebf5b923d81e84e06e69928eff314668b4c8b5e1b939c7c164cca074503ecb85d592ed246fd8736d379d5ab09a96ad581c9b694b9cfeaba9f47ea88d2ffe1e5c1ec1930659d6c9cdf4f3130b6a0ebd083d19f92e108c8dd66bb8dd7df6f20387beb4dbdf8a6a983251e253c36db59b5acfa5a61f4f148bbf3e7d1f3d86eb39618995e5c4562beed8fa29c88cfbcabef2d9cef4f3bd19b116898c4be2d654a54edf5e91cad6463549fb4cf971a167673b46c4dbe48e0dfc6b7b32c3e0cb937002eab27ddf652e2320fd8e9862ffea215f46f0fc20953c1c31963f0e1b887950a29e05a44ce66cf2d72beff4acc3647ecd8cd24278843a66801d8908685f507ef2535b22753cf1dd32caa05dff60207fd5373c82c393fe76d161c3ed71f24d8279a206875b4b4c7df244c07152f77f8c991ff9d57c812bbd7755da624bb6975d5519e0fbff0915ddf6c28e4775457cbc7b51e53775b2a69c04d7fd5a96eae7b180138ec842d353a62fdacaafd43f3cdafd1d7fbba0ae229c57a297bf35678cafdf00f0e1f2e28ee1579d4e1acb3e5305b706b8d5c176b845391ee3c0b696180da8d1f479fc18fb3915c12eee3f62cc03f45a9d187557e2096201df9e80b437cbb34e1a1052e9c522291f8db5603fe00e313e671097b580b91948aaa0aae8eba8be3fed766bae861564e2abd925b650eb74a7d9eaafa95bb75448e2dbe5ea65ab5072ba4f761b0a2f3c623728802bf319a34055e71e9013353185128d27b596c6e23f2f1b29d8d11b27285660747825414f2c271b375870e57f584f2157e959ba96152edd14d3206effb02981a2e71088675a40a19b9755367984c3eedc71108504514617c1513ec4ea69f241308568abc062d271bfd27227cd71fe6fdc15929e86b80a1841aaad7dffcf468484904f0f05be40eb587569b6853746ee7ec15f7521483f5242763f46f5c813210275e05814f156373986970e1e900b8124a389591c978058cbdaf3a67d2bf27d4951680f1e27b500d65beeb890b00510ba29978ad99f67ecec40e7d3d45b29ef08fbded7657804978a3b0ee7004c0e165ff4a6e7c0fcedb8de8bd30b7ffc7777bb4bc81db25921b0e34c83f68d32af4b0013f78b863341e26076abf158fa32593d8d267849c3e738444a4b59348d3e003993143dd06dbb32e4e4de1957240085ade503d3b5fa44453020b72df770474a6321234f6901c6a25ab90f7b6efd56d5d5355f848da930d78d6132d7f5d23ea3235717e2410fcdbc3335f861d9bf35a838394e53d49f07ab4629c78ce7eeacea9d38d063df36776f13cc4a8a8c7e5a37e4acbf3fdb47f37b6726864fe09d77acb4035013b003319d4d6f426d29e316a4287af2a213bf9c1d6618e039d89363014744efabc8269e204e8a92c522efe8fae0826916bf18edc38ec8f0b71b4c02c0b45454f9aee90a1d9b08563e4f9c2baa4a201d03d743e85dba4b7c6bf40d7ccc326fd4fb416e9e89852d3ad9ad7319d195a44808f845f7622dc69cba0cd6b428c62801d889ee0a92da4509514e461f40871a0fc3886614f50060a63944350f96c4cdfc8b471c501e639646db33e2239bae054240002acffe0abec5ad2f9ddbdf9218dc264594e0f97f5733023c8a04d497b0514f6f72fde3c0c37a8e261fe1fc9daa3b4518ce754ee622e7ca6428e16d148d483d98866837a6230ce6e7b21f1c9e1bb30995ba6bb19b0c24e7af4948e465732d708ea9e822b653a26b3ac00acda7d6039e91b750dd7bc0b0d8f326c9e48583f058861613195ef02a193545e0376701129162cc6960fd100106ba9e343fcca2ba5f2765531772c2cae4910c7d64376bd10dfef653e187525cfca595df85bbfb1817ad0da6da8cfe4935e369b7c75f11f1fe5e0ac51ee658995122c90244de341b9f718484d0997264ee42fa25434105a38acf9274d036c57f096e4874567475d846e2fc792e05befff086213d9ec20f20b9f95767ca93a9ab8bd7bebf3a4e4f2fb65dbd35784d1710f86c73051eac0d0643fe11f8b92dab2c2efccd8e1958ba04aac72408307c31af5aef948600de79295be019b9287f28bcc15a7a4e4d36f60b30dc4a7a3cde4973097139bfdd1aa0ce4e87b0068d8b690aedc3167283bd15ee1c078fc675a5f5ec6118853a92bba3d051279cf7ed867db7031d0e79fc77bf495c61a5c32bbf91216be75c2bbd470c0c5ff0f78b46c73aee90837e886bfa7133c4a1da4b61b05576f0e65b9fec9bda90adb71d54a18fc6601bcc385ae4f7660a8c8264b237cab86de615e19cb48e78d0a77fb11ed1190be569ebacd80e0388fcf0873ec6f7aac729ca2014121bd93352351648afdadc5b8732a6bfe211f9ae80fa17a7f1348489268d9b14470266eecae22f6d0a34174190e809d41e1c100d840b26af531eeafc1d9ec43f59ba81cd8fda40e10ba393bf6e91651d3b889b5d2600911166243b16869686f543aa54d8f4996f0ebd5655159cebeae8489b9a33a01251f2d14e51c953b5773b78af9708e5596af2a2bee8d446a091b1011a0fe9184fb33b63aa8abac5dc0d7c974d2189ea3c9e37b3dd6f7f9c0ff005f7b85be60a573f5a14e480e2b0a201c421f726902d9a62469e81e7b15c33f5bd3e2c5ab39bc33a33d4d1ac1833368472fbb66f5bb6c56e00f7ae9fbea66b81b47fe663d0125afbf249fafcd4ddff8c26bed88a5eeb49ceb7d851b190ef9b90b84381bab5718caea9efbf1c6014c4256c11ee8c87e4507ddf8e5e4e628f65428a9ef1d3ea7646d3ee00dd0fd31dc874b9a7f141a14a7a7d8da0bacf7711a7ff993dca8193100b4c088875778d7e9fb3f25a732a934ba840f366cb5b51b77be6cc3ad29393fa1b5090007006a269152b5e9c893a281f28e4d75a38589efeb35a71029d69853e77cd9185dd210c7c301e2ce5ac6f90112e5b7e2b5c3af7b22a1e7e4b6a64e27485bd84f85cf74ea9b4ace4ca0b3c1bca86d839dbd014dea4e9ba3e8e80e3c77f875324d47ffdddfdfc146f04672dfc4f2f2aa398b207521ca7a9c90db85b845229fe1b3bb19f9d1191b15b443267a604893fa34967ccff727321dd7575a95a36fc3dba9c218216ab1af0ef287fee00301311fb4fd2b62c4f157f387811c416c53ce81e19b3a21923d1030824b4e3716931089351ce478f9cf6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"8d0120ce7d5fe9440aff6772cc7bcc9b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
