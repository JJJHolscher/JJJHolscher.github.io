<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2012022f85158e987d6c32d95e2e4602b3016230a9af72077d17e435032b1e70c643462818d8a6c4f19927af4c1fd6afad44a98d4c275bbde10058c5cc51a4eaacf5ff3ea56483a4415b9c34739abcd53397057fb52d95ba874c0ac761763e9b1e213966b2f73e7049a15566987190e6f8aa70febc7216677b920b1a7dd4a7af7031d77b486125071818dc43bbdbd3a78f30a393f738d501e7a2cfab6a62f88cdf0c6368223039d5617d9fc10f83297af4f38710324302727f51a18f4a72a5605398c008762507b15bf57fac05de700d62ed20a7ad7f01f05b6cec9f1ac8797694cc7fc2bb80bd81db844cbadb352ce364b6430a93bd1cdbd8e6d2d9d50512d9635dc8c099a70592142346d456fbd9b140761a0a61b7c6aa8f7205f1bbe046c5f3992968353fdb7d73816c23416182579e2bef9309d9f5407daf35d0527d6b7b2b7e637f0031120a706460118bd3e4f0c46a73a2593dd5f0b76aa823fc55dffd24b280913ea242bf7830fc55bf05286f381cf8281b2b1a37afbbfe1ca9e29112be4ef46252dbc03ca1a6bf893189ac088ea964042aad9ddab428bb233215b708f13dc634790aa709511a73e22219b418d3dcf22b6828b08d82dd8ed902a9b00361c97ec133d688f4f9a4b1d517f3afca17f07dc6ddca8d5d14f22e8bb3edaa29676969f11026548cd6bae1e2bcccedeab1472e46de8d5ec8f2da765583682bb2c02f1dbc27e942c7f866befe27d66ac1bff8a37e46536392650a5f60feaa112ed605233a204da603f9cd297e9cd1dc7e253c5a94cf46d7b2f7b707ddb77b3d4813f093be1fb6cdcb3fd455708d39118962894fcfe571245f30812e5c1d16af7588000b42f185bed10f7d93a66c0be16ab54b5f834cdce983580bca57496e187b9eabe0b880db11f999312304af089488210e60b47375e725062bac064d1798cbf708491dbabd967da68c4a17eda4bdefe17bebcaa102f209f0b052b42be8d57d55404a7a64e281823e658e49db0166eb17cab5d663db95b950366b49c09e784e4c41f643e54af13d54dded312115000a860dbdd3e3ee490b00d164dbe03200a2fee0e2dc97895efdc664c86cfddb5f8f1ce3e806944d46a1ca43cbf6af42a54266dd84cc94da8b26d19076bd1a93bc82998cf1f2f28bed67fb5fe85819587079b560bb4b1eb64be3705d49b9a22e96bb2364976626cffabfa3fd64d494989c4a502cbcaf3075bccde035cdb4e9e436e0e8b7087292c167f00249fc58c8793bf4f6b06ebc50a8027bab6bd5dbe3934088311e00bd528d79ccb26a5d518540d3fd548cb80053e30f9fb1f691860670b6b5e95e8a328df2245ab78c9d5bcebdf146921fcbddeb0b7698d55b2b145e41e547251491f5a94db2c5dc72a02a3f2b0d2adceb5527697a748fae3133f0becc86fc1bc7c77c0e727f00d7db1483cc60e8d5c7a2002b79a99f780f7ad48c5a840ec80ff54b40fe60fa0652cd582927d01e8a10032334395f250e92362d93bb2c8b3d848ea3c7e69d5137a1f7822c231d90b0459f422089bd66ab67d2eea816cea0197667f778ce8e4af34d0de4fbb0590fe42192ba96b23abc657ceadd0fc0d21a96daf033874c2362edb012dd275f75a11f5bb2359e8d9f67b7c69badeea335413399b792d74d1652af4e032b7361a06958984972c56960ba7075dc5bf84de269aab4c64a033bf25277d242d25a02f5cbf3c365608f73f2156dffc646634d9498b0d1c17bc076e6b6926f7179e8f543ae70fdadd5b4ddbbd65028fbf51c260452deff725e5064b08b7e733668e97c9cd07f0d2038bd81c5f330aab53309e4b03997b45eae531c9baf15803e8d0abcb1393fbd6b2637bf0ae899aaa2980af3060d24b256cd848796660f62734501694555ade2f9033fc8c5eb947797440202cbd0aac8059a6b749d25a4dc23d59711a578cb34db1943fc78539624bdd5a195f8bf1499ffc671bf5cc358002ef0d1509e959f81b9c9ac5d8579ab91940789d71e818e87da4c21afe7d8e090c6b8bdac3404b5ba0dbeda8f058abf1ef46500e46b968386ae0d3cc03b372c086351cbc57e2903d33d790e064b5da7ae1214dfd5865fedc753394bd9ad1b7894a26d5b6b0d15a6dc4d280a173ddaf8df14659ac0825f2a53e7fe27ec1f3886b49615c3b2b8c953af231c0ff8b1cc2014b7ced644eaa4389a4e2cd0d02528d19b1b40c361979600f7f0b16b9d4d2cad3bdb527b6c93b3a0e2a31e5e08a68d81011a6a9aee9a8802b64ad34bba8788e47d7b810d2240b93df154b9aef0899685b06818c67a9b6d18adbbceb3387ea6482cb67b2250be3a932d1a853f232f4388132468ca4956e5c999f83f5f7acf541dfeb562098c2d116ff251a109489aac37a1d055141e1f93bbe0189c0bd8c7a1813cbb28b63af508d91205af536b6c93108b53f6c8b22fe9145c6df8bc350c4bc30404656f2959705b6e5e02ac02c5cd8e09615a205efc41524a06aa7654358bd0133c947611c6d00afb730c5a7184d70f54cb3cf481d5fed83bf79e7aadb9c21bf2a7d0104dbe9432192f933208d28077c7536992edeb309eb9d3d7565f3de600ab20b54cf011737775ad6dad2a2f2bcedcb6bb0433ab78d019f872cacc0763d07ee0d4e6616c4385b42339183d6bad423e8340f51680acc07bc02c6b09b1554198c396168b4323d449ae7df7035093f012b7cbfc2cf649b3825c1932948ac475f1082e9bcbfe87a63fcce00bdc59eb22f55ceb1b3b53c4d78b0db96bbf80286123c3b71476c501fecc516c3a245f3e4df0b7d9288358e232ea66d00f71697a8bc564eee8af73dd71044bfadd90e1f3d04dae64135a4c2f767df3ae0481ba99cfd6c765c499ceabfa005d3fcb8460cad8751274b59839a72bfd698a432dc71dff4f86f59089b2d08366b0aeb8e6761e4e5c8440506c41e591175b6c408bff9e85e7c0c43125ec4f64267c35f93f70e83b0dc1e895f445e683e3ae9244b9b75267a42f310a4c0ad4f5faa92ea0f3c2e498449e2437b23120087ae022ba1864ccfed51f5b5bcd8216cf7c0e7ba505be6d42327fd3693bd5ac2f58b719b779f58410ae1933c98a69e1535c7e02ac16ce0f4112abebc777fe24f86eaae66e1705d9659474b1d5379838ff29eb8134472f1396e5ccdf9ca6d7dce668cef1622fbdc66fe0cab19fe75af720d2ad4f88f774df5647f81f9481085f2f92b2284153363d4179de02171ff786821a2201fb5e7d419220340385fc50531961cf01011a85e77b0587a2195ea15f5c519401e57d2645b6aa4b400c0d65d8d8771061f7f0029e4b97a1b58665a7d23cf03914fe5a8b8968853f43f6769f91bf08875f5e13a8dbca40a9503867b9a62294cb36770f2c930d7c81c0e8b1ec65df1073d12e22136e7d6e4fc621b7523cb7e48dab80b9377aae3f8c1fe73f7e5fda1b424f79818c3eb90d88f77fb925ea0380ce843b3d0b51eae5bb7435b3743db61c6fc583107fa0e2fedfcbd7e37fb15494b888ac9e95c5b50614a0484549e3c0c1a90eddf33c6a7e681964bb4e37ce5c79933db8442dfde26224b5c7c7110e6ac7af38a7a6fd172cb9aa367a14a6ffdedf3c282f562f560915081b1bbe8ba3798ee530bc7234e8fc7b7d4a1da0bdb9dbace5bea9f1660907dbbfc580507dcccd3e4b6f98dbb45b4f69b0da45d194cde5358ed2a6f5f76ca4745b91611444da07be2a0d0c484b77fd2148c5c0909f9ff1b2a58971fa1180c110e50015a2359f31fd298aca4e67bcabcc522b3689cfdeb1b4bb12b2ae203cc59f796860f97888dbb52b65f3eee1fc8932193d0ea47e49e0afbe04b801cb5f2e844a7948723a22cb2d7b110ded1b06052280e52fa985825a8ee017fd59c8911022a8fbb813962a3228a95487ec52d2a318fa3535a483f1608ae8944cc9b1411b8935b83d2f3f3b42c18df10e16120ddc787708846369b518638eb043470a38fe462dadfa884ab65ae7a242813dceb4487874765c29ddea957a38640fffa9a5da0330b700f2747787b6e8993531ca2c06c4478d93f33d2337b4c55b670014f9185a5004610833e45f6224159880fba3146514fa0a8b2266ed67f1d2aae37971383f566f884857fcf4f18927d91192cb71583160e8aff5ab679ac5a881c300c29fac3b7143d920097d6a78f441a3c33bca0ed159d889a53f70671735bfc44ca4e12f1435e325d69e0fb8c49364ca34944b1d822db7fc027017d3136b116027cb8a596ba16a62904d045b68765ed3ef05d4f9755e81f3736467e083d0f23255ea7a36c1f0f700952da632e68a93996af4eef238ccf7014c647a8ed3d9ec4f35db5e627635b9dad8b7d2709061addbfda1ff865f943395cccb5f0ba410411983a70be721f10e0a82d2ed65496fc15f9c573ecb73d3bf78eaa67421c8929940c3209034b6c87f0276a2e34aece096a7152d3f2598229f7e31cdb5de3a592d2b76565e1107c7bdd38f260a26368ff7a7cf1e41e796e25626b2ae2483b0804e19416aaf00dc6840bf754723ac0061305dc0f67de296176cab20978bd9885e44b54730256a94f3bfe69b23428ae2419c0ca2b6446262750ff683be65c0e231458257453eaf6c25ae0352a7bc5f8aab906274c156cc3b5a0b97d6bf18ecb6083fef090c3ed1882d6019d89bfff71771ee121a76c7649ce45bb520ff60ecbe8c21946e3b9e3285ab33d9199a514ea0dcc3f746044d52937c94775521d986910ea2090fa5fb6a1231527ce1a0459c3a5bad69df453b8c2a5dc8e87ff8a8eddd9623027c0e87ef2c9ac693460e5d4e67d0be2516bba9a7b123cd1e3a6c452b45d6d0f6cf85c74d8abe802fdd791d0b2d73d77ee80d1e59a1cf32dbd9f6db5532e9c9efe6397728cc448278ade803801739123c3816034241c3dffbf548b46b8f03224d3aa50427eabecdac2fcacdb54d5d4790c7098ea891d8ade239be82622760c68e5793d50b02251e6113194214d3b512aa87a539da9f0e06e951bd5c5597a2267b955b52058ba709415dc289d79921ff5d268a437f0c46c179e975709dab5d48f7ed02fdfe3ffba76d77c7794cd1587f432a19b7b3e25c02e0a42dd93906fe732ca78fce0ed6ccc078680209fa314d9f6ac50f5fd609c6f8c275b2f133e5b24f3f7090b2e7aeef49f1bcae52ec1765f4f3f5ec218dce9940463e539fceafaea8c30221104ff5b03c449c793c1830d0252d8b4bdd9355abcd95136f03ad6c237d61a0bdb9c0b7a739224722a178fc3d09a0847ef3f1c75fae2e07445dc82be74d5d8a9f6a2207b665965a7a024ac36283769723083897295a78ebdd61b6d8e6ebb992e976c4e2efc19ff59d7497d82783be6b2e5dca0c8625609e9491836a38f17f58e3d1bd7d7c65755baadcb4565e253191b725300a503bdaeac68545a5cb262e6aabe3ac1d12a20438ace93c84ce43ed6bf685197d70f2d80aed9966cd6498cdc61ae99cad9f3e4dec1403cc24205d89d9ca52f0421a1e2c9800040a83e0992cd0ef45961a6b75fbd9592c7d04b5f721f6d036921b7cbb69a48d897c71350408a190b1c74fd20cd9b08bf07a48bd3433fb71ca201b6e3ab659d34c0dc79df5bc3572a0cc30de81a981e684af3845ae78f6c05516066c5ac5184f6d6f452a09991a2c6a01c4da4c1894fb6364f6653fe66ad137e1db50beda336325b78e759517274252f7480076e96d7e2b242e37ddb1c3efd58e3f4b1b77574278293fef4aaf37a89edd0d248c2c1ada4ecd053797c3bf5d7d50b68855e0fc377f157930464dce623dce9fbfb0cf1e50e26a8de86096e94d6564696bee7b75df15c4806969d5289065324b9b090a58e64d10402970b5fb6cfdebf7044f78c67d0aafc33adc81e9a142976271bbdc3c5d66a974986676b0a5c1dcaaec07e954136cba887d83eb347b525bf6aae867e4a0496162d6a47f2e37970cc4818f79f66ee96536129123aa955eb23d5c8f77b96c909381869b4a50f899d34c09aac79bc73725925d318f08fb7dc9fef30a8cb6043e5eaf7abf8d15afed82578483cf4af7f7bd69382380b4e1dac5b16c4a708562cda8306a30e6b510843e7b90f8b29f430e010693756064e3b4fa45a55cfa3b538a64553a8c2ce7f0c4d4709a9e2e5ee26918416ae5818de3590df86192d2eca5444ff5a5ccab5858859045859cc0ab8417e04de2cfe896326e8352ebd9eedc6d10d2e9e6db79c6d4e91bd33ad7a5a02add0e91ab75b3e8a6022c70b1c269968723ac10d6098e64390ae55a72d5b86866b34929ad3020820a04414d71427b309459494587f8de4bd95978dd49954e67742e9708138e1d51935c9dc67432b23ffb8355259b2a84900db59dd817ad5ff0c38103fd873265dda5162375475bcc4ffef633b3045a5f755fb1fc957087c3bb5d7a3b5c06ccb95bf5c046aa40108371e1054d03e8ece9d219e27a7ee30908b4df8ed07df755dc7acc700dd4993fa680aaffec34a839392731734704d38c47b848ab5d6a6e87b5ec4bd0587506cde240ad8a9a66cebf8173b357bea073245301a41d09f1986095d75cf5d8fad14cea733c82bf37b67039ace1e2c449dac233c4b8ba9898267d926898aef549314f2a0e05d4664fc92b00e101387f080c8c2d8c54defaf7018d59d7cbd16a9aa5d8e4d3a775091784f0669e06efefd820c9036f143666ca358a1795a9a87daac0c4ae60b43f9f11d68271250cb99eef36466235c65253b3a38e274fb9a7417bcd588e6a510ad1953548752708e8c2706793e2acf6a6015ee55dff573493618c36abd0b3bc39c5abdd28665c1d8ee12124f80f631709b36b7c4f8d0536f3ef10e772a566e0c121bc07e5f6ed022feb12ac7c459ea358ad799b34e302b0338ec8f16861ec51f1fbe80a18a67d89ad3372753261e9e874425c7b37553bb9dddff51a8f80731792020cfe77be1e6a740ccd687de7340771ebf123d62502be0609a565996bdffef1cebb1e818f084875b81eca046634492b11b5120e42f58b3eb88f8bc230358d20158baf3ffdbffd6c942f5aa73ddb89460a10c5c8d4b50f503be71d2b1f69671115f119e944e3e6abd423dd57df789e01f0cf2bf5096910b64af2bf2eba1bd0a97a06d504a35358eb31c56fea7c56fe4cd9998b5f30fcf172e8a8b92f28b8a625ecb58ebc001520c914de6985786638320a3ccec42208ad8506e27a2019773b0ad1de5c60a829f592cd6f1293425c8221b2976ee1761f2516d2721fb7cf3f8d15010a19c5284e57c2de4e8c74bfa5a266977673ab0022f112ab44b72c73bd986d3b57b6d08557adc680c221d64c6ee7526ac369b58257532076a0f2011168af4fa1883fe6d474c3efbfdd96e55df0b2312273857600d6f49d759d642a773b0cf501a7e7418da522ae24fbf68dbd336fba114d75363cf31d0b116b71a5b2b4be1c685579bf898efcf6960217451267f2f32af1b4a47ae843616ba586a1d6b4987acec67c3ed5c6daf2d7099c224374faf285158eed6962e34acc652c5061d0ee0780ac3cd036d62035d8f3dc75afb3aec9d84b690282cfd1bc01ee13b40f77f9bab2632e63884b11f9fcb31d77c7ae148df5f49db200a9bddd800c20f8887eedb2b8d8a2e198888cdc56c7a279cf85f3bbf2608490a9bf057a9b74a289348f1a8a6b501b5b0a66b58a2be24d4c5710d68226da6c0f3f2856896c19b1d786242aa15cf5161890107a74c89058e3ff37cc970e61154051afeb11944e7c80c73ec224f7913895f5d7252faa5153d995651fb84c67311bdaaa4e30b3f2b19bf7f800ab37216bf19aa2314ab7c239d36fd53ba344d1f9bc4ec85702d86d8909113a49decfd555652a4a302997e29d41b9d791af2de8149ceeffc71c405773ae24d73f9c38f1e6006d4f6db9f85ee06a7dac0d42aff7b8f106df119564c40c736c25afb0227006dff1e2f133462fcbe90105cfe796b3ad133c2f48efbfb5be1bbf159abf674e8a01acdfe5e6e80c1e8d8a104c7bb9988661bdcf3636b6978234a523e3eb483a753437a68ead77bc45bff4a18b49eba5d11a808ede80cc01b200d362701123b09a08c812c71a63ed1d5ee3b41ced6813336a78f75ad4bca1c5807c6e0b74e6fedfc322822aede89375b8d3a0d2dd2597298be6398a19c42f5e12351fdc81e43d00b0f91cca3d9fdcc046da4a32e1a8ef0f92f5406eb7dbc63177d90a29e4c5f2187f9e6d5651e38e4483ace0dbbd7df56bdc39e4f9f0e891320e17c9fc5d60f085b275874683b86791adf9e8dbbe06c3e0c15e79c78016b3578001fed0088adb1de12fd6a36604960cd04157aaf66705a2a0a5ae3e9348e7e148d8f1c42cd9f8afc0ddb485e766b1a617f8927583273feb62b31f0de9322a51668abc56e67d4ace87ead20d56efeeaa28f72924241cc318e5b43014d2e4f59a47298c0ccdf1d846921364f1e01e6dad555671172cfe7d3188a10658ef0138f5dc89b44f83d98d653b7b48edc9f74c0623802d756c5d386c16488461c7bbd17404cc178dfd6fb01758dc6bb5c19ed852e7c323f12668ab87c0e89fb5e7f1a58b2492ab068b52e39b1f0f852a1d664bc0b075464ff02498bca4f249d5798425648e25188c9ced8e0af4b9cd563bf65b15b0a32050d54eefc2224c7375b40b2f4526f5d740079589aecc01ddbd85ef143a0a1443043ed4c53e1f140851520dce550b81bf70314261695161aa37e88ffded25f31c55e9e0c40d01b09b81f1ba85e9822d3ebb7f82e2338e7e993a7830f12d8fca75a832b4bd21b006d143c4b43bf715f5e20082e16edc884ae74e3db50883b0288f3949d997e047fe8f0b72f40c294a7ce75620342734caa30c76c3fdbc8734b43a570d51613252fafdb5b89cf0917c6aaf49d316ff4e7ac12e2d88f215a6a0a3688da6ce68308d3a58bbfe5bc9daca9e9281cad047a02cd7f3772d10495a157211d346a3fc5ae1d9905f19d123984ccf455cace023404676cf8a9a8acc4019432c857855a340fb8986f36da7b6cd500411ac7cdf523bda009fd1000737a18f5706850b7d32fd8677570f7e31e9cedc637dc7a22165802e11b02d9fbb2ef8baf1cd5908bb74df458c46d32957021e0ab8c12531644bdaf286399e1ef5abb8bdf626d5b85803110dc19c09ae7783d577aa2c2abcbcd585cef8cc7d631b9c37d4d246f4be77287690c8e8cabf88ab9b53f61e1d4c44eeb98dd6aa9c858fc2f096aa4a0c3b8f4fc7525e2566bdc8de7dfb7a28099bb8cfffeee9fd8f0eabc7a06c67263c2b846ab1e3987d19d3e99c125fcd445d1329c175d5d32a06310b6b056e577cfa5dded6783aeb4551bfa5903fca105f5c2db4b49e1e156ee8dbc15e6164714eb02012b2f7c544265dcffef37b3d0adfa8366b7181c3797e37b79c58876e9bd007bdf9710c0cc14a65398ae04efdf636d445a40fc2a203c7db3f6acc6243943f6bc5ec75bd20682994d0838f2c05db3b9c7973fe3bc544625a6e1b8355a8809dc3c6d1467f70a0dbc3a54bf2138bb61b8fa1ad841a705fbf33cf9dda85b1a343ac7e4e724c234e74dc59732e2a7d0c6b89f8b3401f803d1091558934b941bc0d438697983e1c89fdf98832cb6985b8f4a30720d934329bd3b7ac6664c32546563a7e01e413414563da416e4880e9674b7b27143080fa329096c193f16b445154ca619f2852e23ff9499a2f2fbdd9ef95991578630f3027c779bdedfd9c31ec5f2153c95e98bd8d397a222ade482caf7658f616ae866fca27389de24d369ea49c28713507c2395eba3ac0c62f3161eec65d07aa37f2fdc8d01cb06c2089130a7a4e59c28f23dd0128f1acc965232b3ab577f7d806e169cbc48d51d4333fdb6a3047172902bacacf2336195255ffd74241272e57012891380f4d125d3d54b584c997c46dca5b036e174479c6c29b7a30bb3d8eebcdd7665ed82a052c350d0b81998fc65266de8ba7a5594e01e4fd244228b554c1bbe64bdbb5932733ba2af09d71c0e1d7c2da9ab9c869306ff4c178e1ebbd797aaf8a1be437fd662021fcc251600163b621d85ebfd6d67e080d3fb1a016b3547ba72fbcb1fa5bf8ab98b56a4e1680816db1d79636fe8d00c18be0702228ca19d3c74fc9a3d70cf0ea1569b847a31f721690c7cb473d8450b2b2a7be381f5740fae046ad7fc0341657d097939cd8f4e33be2530b87b628a5804dcec96014efe5d079c877136caeed8394c3b44aed6a6d7751c16a186ed833ab442ed3e70f705418a0e849a9c8816cc5a276eb8f8722e3209d234195af1d74383170b76069a51eb2d1c2d733c94e106164f0d090ed63fe81930ba8fadaefc6c8ab6c047cc19a019fb5d588c098f54f6cb9516a61e6ae77e2fd94fac49cd9ce795269fecd1e2986e5daa5719f9f8b5dc99d2ee09f7b75fac743defc1e9fd91c7aa25e485f4110f8053e91340de46d6e0b52721c74f902d79241395b9ff1d0e3146e6a576043af1a7b80f8e7696774d2a3108632111460ad8736aa2443c64b587046bf6ba703daff515600b4b93263cf324274bb722c5aaaaa55972995e1f5d5407943b15c7b0dd03e5b3d3a018a1b060ecaa47553e3c9b0839aef33f9f7f3d932755dc6674010333f0353be35b8490602b08e1493337843ca76224a9b80a41667412aced9a0cdd19ce34d5812bbe70b27083a46ea6015f26c6df3e078d5b5548b86f1340e5d3a160d7f825ee0446f5a80e62fc4c42539a36c2934553fd6776eb2eabcdef70547449e8970cb221bc556e3b9361943be290c7b64cb2a476d91c214d8080fb82d5966eff94ee615315898170b45764ebcc68161b8d3abc29709538296922f5a71fac5bd2672a379a10f81e03a293f7b987c0b7e14d5c3f99f654a2d55a48735f0b1cdd8bf999d2f3227876dfee49facecb661169de56fe2b4381bb43fca4ff0f80ae4dc757a832657559d4cb05e6c82272bdaf526d8ad9bfce8ef4b38f669baee655a1d57354ee61e6634aba1fdb5d964103e508e352dc40a3f75fbaadf5094f7069f9aa13d9b11e52ca1100daa95b536d9ca0772650a4f99d0c26e6039a4bf629a0eac740365076e6240a4959372cdbd13ed978abf9c5f87b0b9d912047ecc37818f830a6994c522041bf4ebf0514e50583dbf3032ecb5f98380738b026fa066a322a87209f91085615b38bd8bbb81698ffc56b64f1195dc00cec131f2c8c1f2cacf88f0500ada384788db67a4fb23474a0c7e88a7a98c4ca84950a5671e94f7494ecdd9b96db81cd6aadc23c64298e7803193a6f6d759622e97aaff87c16efe9169b9a77fe740e96401c581d38aff7dc244b77b8e8a49c3068987685e75824dba69d4b0f61fef369b7efe027728b1814a7aac329169bdb4324290c7b2fa8fcb97f70eb9a38635fca3ff9256ed6df7f0386b6724580f28e2ebc95a94d8c02eaff19352c14ba25951773fb7a05bcc664314a96b4277608f42ac16998b161cd2796ec1b7c2c99d9bd93539da001ecfe5e1620bf51d4c1639e222732b7755181a2c5bf74dc5952ac7df0c2047075deb199f329511fc75bb8579c0bbe04a8cc0b49839debe1110b55f4c5fcc292f91caff9a84158f78648d12b4e2fdde6f98ed1b2b8a20a0ec2b44de4581614fdd83f8f70f3f29112d42affea478b41f84343211594bec30061a57cc9f33a188c72b80670ed80be6e0ad31bf778008e7090aa7e5253a80a8bedc2868299f5e1ce1e0f0882e3e0da6dcd21ffaffdd494eb56e111d8f80fa2f6fbdd720be23ef6f733ab1b98614e801b7689838b2b8a9d8654526776379b119b7be04465151d25a804d51322be5ca76dd004c49dc79ce71d8bfe220adc0c4b646814ca82725a73f344ce9b997c6f08fc469053f164e713a798b2233bc30bd4e2ec3a7d429de1b449a196b8d5341015bb47aed9e1db73aad4d7d2b4b68add533a31cd90b1656d7ff7bcd0edc2ee7dd0a5cb5163faa7ad511b96376f01b7d2c46aaea1d17bf4e46b1f41502130b36c2eac5a207293434f75f4a28a2a57e9bd6582ad2b1f938ad43965f6bbafcd2ce70db88cce658603f5990e54d50a124689a79b55c02712bac581a0a5d46c36accbb4a59d0d2755aa85c8e07ba3d597daf9b2ddd47860c6449de8697e92046de2041c841f9584484e25d74121f95ea74e2a0aae8b0024bd0aebe2df7278d74bb0df1fc82eeb2a8715962ebefc4042a2bb8df57d636131dec94012d8e3da331ba48a7c023e811875e952b57fd773f28d94f1adac1eba34906cbc7a3781943d461beacafe32d9a96aa9d87820ae623516e1353efc650c34a776f4380b62a6461a4dae75520021c9af01f7d7e018062a95af05130bafd928192f77b1b5ed986356b6df9934c42775130a9679bd20394b7804f2190a084d869dea6420a5465f399d992d07085adc4d81453ac1dfbeecb7feda0396ba7e24ddf808cd981ce3484e8bf98b1b612ee067a68d7f5f8cc964dc9b1e57f4a70986f4d4ca47e4ed1fc2ce03c7929202d653d8d00b3450cade9a5184dafe21d7b424743a1471024d8c1a02710f5d144b17078071b5ecfad5d59f2f32436f2dd2edf0596c3740dac4862b876d7667c9374fc53c11d66a9ae47b62665366c3f017aa555b8110d4df9c2fceac22b87b8b6c10512e81cd3e6d1037cf6712cf998e4b050ee3d7859b76200ea678ddf60bbf5ecc5721f5bca10ef0879b3c34a05056a90b1e7200b67f3c68536cc44d8ec42dd7af0bfab37b41ffbb3f8b102a6cec25c298bcebddd9005914b6ed666f60774cdf47c258122e050fdd91166f665e8e0b4186d97cb7dee7666697c6932793acbce9bbf9aadd8bb59f89668dcb8426b0384bd0e0dfa8ae73fdb836411a46c7abf78e3e0f3b133bb872df72c532e0be7cbc7422ec11f343b8bf4762f35afd062013eb9a86a875803494c7e42f8cb1297457b8bbd37b2f6292be65cf7a55cc3ff2185323507b1a3a45336c9439ac6968ac496f9bc09780704c0c149db16bad06fe1217f717cef3bca127b7d403ba207e0226fa4b7fea52b377ac9b2ba7b002b5cd4ba3c7c525172ab170e148359dd7c06e5ede6a061fbf94f2e6ca2ede12ef3d2df4c761884c7e1812c25c67a5ffa5fa1aa757b853324bb8df3d8319af22dbffa0779b40712a295b300a3270c91c196338f5046630fbf4cf4291b234ff9e512551755b4feb33b9f7998e3458f724ce3665057cbd10474e3f3b957fe3d6a5c5de20cc2b65bc0ad07c11ea779fcbd5a165f7f422c60061d7b7d97f843fc1dd07228381f47f09e31ede866bb1bb9a0907012b97085a5b19f5302086cfd7a39470b714a82b87c2a822f30684d6c4a46ffaba1a9b579c3ba898555e722e9cae56abe8c7fb31f410ebe846cb861096e8ad256a26807a974712df0398b9cf1bf742cdfdcd34dae5ef72154fe6f8f4c38dd0627199e93b70becaedb76833035c7fcc027617f6ec9700373f1c1859e1c30221616247a0c7039c845ce0e048de3525ed703898a110f752059e5137fb944bc3255cdcd3ec89e1c0554cacd886dec569cd26bcf81c3f8c59ff8c657d14af84acbf851dfefaf567033fde45bf28e180c507f133b6842a031410a426763452e95720ef1a4f0f6c6869ac7291faac3b0a86fab802646f11412d677c63d2cb46c4431703aa234ab653e1e9414f8e521ba544b03cf964895c2a8767800f30a2f59eb00f15698c5f7f24bfe4913c57081ed23e43d0694f7da6dfe0910c9f43e2bf4e7e2526b321b96c440d1262983d7ea1879ce9d249398f149259a8cf48569c69fbb287827c8b962ea95c81af0ed08e3e7466d3968754845740d893c2b9dbadcca5d98417eaf7245c7bc8ff850ad72d3a5fafb96d344d2530f2196d86d3c84004ee69ef8100b4fb396c56f9d6430bb91bc92f3d72438bd0d77a65093eb3f1cd1920cedd6b54f714384418360ed723bb84b0fb3c8ca2a1b453b89e1c889c415b0f9981c9ce69bc5e28a775b504419ac9dafb36ac13cf8323a5747427f0bfebd0831abc0f13b50b1c201fb7c2a9ca3264ba69132808275afe95bf87fdbf965487370963d38cc83ae33e066d9fe73d54693fef69ce3082d6745a6536f71586252bc3eabe4fed4e0e5cae72c4f7188407501f404cf6012655660a1976925b9b8de894be3f63a42a2e7721d325e257d85a7930927e3199f060b8a33110dbc12a1d9bd8eab3757c800248343178abdd8ffac1a94d3dbe830f22059d7d9f7d813ab81b5636b1fadb052f25f4b32b03aa0037289cef9d4c58b44749f8736d2f588a95783c8a2aeeff2494b2764e9ef0b3e5f2cea4cceb225c9325390d60e2cc04afcf425e1e99ec0337b2c07c08683602c360936b704f28ba784d94b44d949359399e692bec1d7fec34d55e211ba631f0c808014e0b1335c3d84f65ae2d9f131ee8716f7e7c1df50bf5cd52d43d295045377ed442b7e36f7f3c85009d8d581e1afb6c1ffa2c046680aa7697264bd3b15bf8b36733cd9124fa5c48249c35ffb3c4871f276ba6884349b86acb18fc008369dc7cfc45c560cef021086258fa65582bb83bc9e1d8af21f4193f344fd968dd7aa1e10052e8edd1bc0b92fcc27d2c01dbfb8fb760d99fceb716e4e4437698027759e30b13c173fdc9c05dec912afdfa54e801275f8570ee26033c3c71f1ace0fba646a2fd1b65d9df2d59a2de7fb22e9a9501c908cbccadcdfc33b493e1d6d1cb302b420316a6d9b1a7148d6ed3f3523ef726db4b92310bb05daad6a5dfa5c6f65d54dd66d8e56403bd2dcd589ddd33e744bb2d0f8e0192a3c892983524665d32a7d4486c201cff4b1ee574c54ac892f4428670c5e2fce2273df1788e739cef330185a0998904abaad90db9f3d8d4a106de07ddcb70005d6340404fd191965033f913dcb25bcdbd6729b310d356f7a252484297bc7c9766644667401b00226419a64a09222e2e027c66cd6a24a4a9f4628e3f5b48e32de8854e42a423d97142c282eaedcd4ccf3e3979bb3f2b469e1c45801afcd8457a087942e341f1cbf25b67f96aa3854b0a6834865d93b495ed549e682ab57ac74aa1521dd61378919ef1cdaaa2e5f7eeea82bf857f38f070098060a91e647156206c553a6be6c57987d310e8623b3fad682d199fb5a2f63ac7f861f62417eb3a015fe84d396971b21dd259c110c571c2c53a0abe084fb2bc8e815814d0365c64abd4959f5957f72d2e4156e193f0209d271b4553e03620b56a3dbbd85232d7d111dea3f54a65b26eb01bc5fcd7a91b4a616152916d564e67eae59983587bace5928d340cbfadeb2984bf066d79edb427c5d2ef96659e1ef5c85b9715741c1de2ff6328163b737364733af56afb46862585850821993be23e2608e6328b2d2895b6f86a6e92981c0ca1b8266de944aba326d96b8dd9ff1961c2c08d14ac5f5fe7e7e2cc89d46b59a26d15b5ee9578dd8fef204d0bfc48e97720beadddbf9a54f283e181fcc3ff0009c412839c6c459a752f66c19018f71165aefaaf0f1303babfc0166fa674268681075c979c1b4a9b158ff9f695976cfcd03774349b0e2da28eeb9893fd8dc32706dbd3e8f5668b6119ca273d6c7d369d513bcd2f0b9e6182ba038bdba420152a61b3e6a815fc37f68395813d919a45f364db23287f823bb3b35334f945c4148ac19c5387bdded9b52fdaeb4e04ecc721689e8dcfbe7edec03d1437597f0eb84ba9d46fee938d3c744f452cd8f6ada91614f669b808c84471409fb76ac58a183cc873b5e145fe3fafe7618d6a4ced03c25c8e78e938847a7d988806129cbfa04958339a1a406da03248896be30d219b811e4094db836ac6bf3d065015c7f34c8672caa5439eb0828fda984dde664adb4c26fb652f6159716187b540e8a52d501e94935e80c7bbe446769f5a957e3d0e610bdf2917281587210a2d98d542cd3c2945cc5c81b174b20f83413575b77f51ca84c777925e8157d578ea48f4dfc85b473ef3fec836cc598a5287489e910b54e1870ca81cc2ff8b9b62a68793bf9ae80304f662f4589238865ea8ed89c30e4324f3eaab4e2eadc13cb49445478318c5f63040df1c5e9527648e77fb6fe5f4ff160fe683e1bcb0e899a713ff5a892471ba5f13ee2f4fe437e111df013b9e4ffd44094e0db3cf11d4301fca555362d328be9c1113004c65fa677c69eba70af28536ff22db374b605016d38cf5f462010487cd391df55c97a7fe1310b24f8af77d35fe8b7f8e4f815ce664b139f279adf7391902127196b97072d19f6033212d2e68ceadbbbe68abb4f5becbc4d2555702931cf413b3f0c78bfae249ff777c6d22e9053db1adf3914002cd2fff85aee5fdee56c2e54a54ea0edcf689bb3cc04cb14ecee1fc08e7ad18010a135ccf4bd21c8daa51261f463806462b2d7d00c86b741e400034e5acaf48e0d3cd4d4e1ab7c3359aeda51218d8590ac161fd6f4e2d292b0ace71534db7def185be73f25f299b9369d1d84ff9a52eaa4d33779ba71ac68da94456c563ad3259ef0825161404195af595e6a71ddf2e2a34ad4236d7aed03c58f225282d41725e35d0ea3e464056c53445fc33eb36407650ddabc10ecdcef3632dc0b18f7b8307fa0af5f34b7159fc3e73c74844e66e7ed5783bf1aa1f23fd0f94801058e7d4bc632dc62fb2936152c24b1ef420a7067a9f25477a7707e1a2611ccddf5ab6324fc036bf45808a7251b7a255b11fce96f7639d5c6d8b909e170458c32f79e8c90328c50adfcc44956ee5961e4f6c7bf00c7a2b1905918bb4975afbb0c4cdd8c0ae3e53725d128b22ec5a308411f775d8e2366ef0d66ec36704ce2fbd3da5302e2af224be17075edae7f3e1ac8ab46dcc53f2806b9d8ace6313b140e409f4709029941d2c709c0d305dcedd95ddd676b199a3166be095f983714b350b7b6945081780a33760a47ec11987ab0af91052a379372c863280953f867609fd4c3815455806739120f3199aa146313ccb57f112164322ee4e5cf8a4f603cb687b2a1213a1641d0c1832b772baca4a1894f6622a62226180209df5ed9b17a1d7f2b8bed79b01534d90110ea1370923dcb5ca2ac2262d01ac9b2a6988260ad3f944d5d112baa4f97c6effca7d1c5b6a7ea5c9f771183a2ace3792dd5bf7e8a4fc047e99b1db385c6b4c0c6f576ca6a2954e5e112432578653cd7cd0200b8bffad318e18ef75e9b78cc13f072821487f74e99a00ad9f4ef3f3fc7c7b0680c33d651a34e44fc6e62198daaf2e4bcbff4c00f7034b9d5d8552cf30776f98d4932d6ed0ad051aa7b26a3db6744f28a8afb49d1c3716534261c494149dba63bea211a65aa54446db0b7986a02759b9f7b83b4baa1f4e141e78a5dec3f9d94f15258489cd80248c83e853bb3310e569acfa59d747062411f39f1200e4cc023fcc70d415b6e8ee25ecdfcf788321fa4937bf2060546ed2ff72c9ff605331914524ca851806342402fff01b5319fd291a76251f6cb36401610a9df0b49048706b3ccf00dbc202a84da0897a635854459c709ee5a25a3fc2b3386270575f6db7a40e22471a05d794b70fec70b4bac885a10be0d64ef30fb1ba510fa4ebeb6064299fa9d50808c88e568c1d6a35420f361e8833e89214bb7cfa33309bacda1620540b76697e7c488567b31b24e30af9c4c9ef06d4620b4fc6e818300c9d0caa58a1940a33cf6609a61f0dfd82e68ebb3e1389b7984eb21fe6f0fe645ca480fb425ca07d7c20c847f31b6640ef376159f0880b386129cc6f2c3ab7f2a74d9e50fe785e296a40fd6ddfbd03d5084011beea6881c722bef7bfa78daad113c17dc81eaee328bad5125d73eea48e07051cce589e3a41bcb15c4cea2d8badf45e17def61fc9ea1b600eb5ee4e4b5cdf7add16b6e966cde92ee96e6cce96e5198734f3a82488265e942efd723aaa35aa79a997b4969655b9ef74fd70fcf500b9f502c928f4f2978850cc4fc9e7ad4d8936d94f356f0094a783e84f0752c01721768683ef1de4394b85869f1958c85fcb0cf3b7afc422b6b0479bf24eb27cfb203152ac32a7b00f263c50482d75cd4123a0b677510ea8f0249a3737269c2f05c511d988062b6689a5aec48f8a3b08e7f104a3a01ad4ffc6bf336d5ac6d92bdda4590d1a51ed59e61c675ee9a31b61777a9d0c1f64b9a7683aa6a23e09156241cc21b13115417871d97e5a84869d0030968096abec21d1a6c9c9b961ae99c1f1eee78823ed9","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"8d0120ce7d5fe9440aff6772cc7bcc9b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
